/*
 * Module code.
 *
 * Generated by SIP 4.19.7
 */

#include "sipAPIPyKDL.h"

#line 280 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 13 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 201 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 19 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 331 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarrayvel.hpp>
using namespace KDL;
#line 23 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 159 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 27 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 281 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 33 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 27 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <vector>
#line 36 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 352 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 42 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 48 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 102 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 54 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 361 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 58 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 62 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 44 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 66 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 100 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 70 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 207 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 74 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
#include <kdl/jntspaceinertiamatrix.hpp>
using namespace KDL;
#line 78 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 111 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/joint.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 83 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 153 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rotationalinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 88 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 189 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 93 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 211 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 98 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 241 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 102 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 261 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/tree.hpp>
using namespace KDL;
#line 106 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"

/* Define the strings used by this module. */
const char sipStrings_PyKDL[] = {
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'p', 'i', 'n', 'v', '_', 'g', 'i', 'v', 'e', 'n', 's', 0,
    'u', 'p', 'd', 'a', 't', 'e', 'I', 'n', 't', 'e', 'r', 'n', 'a', 'l', 'D', 'a', 't', 'a', 'S', 't', 'r', 'u', 'c', 't', 'u', 'r', 'e', 's', 0,
    'C', 'h', 'a', 'i', 'n', 'F', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', 0,
    'C', 'h', 'a', 'i', 'n', 'F', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', '_', 'r', 'e', 'c', 'u', 'r', 's', 'i', 'v', 'e', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'p', 'i', 'n', 'v', '_', 'n', 's', 'o', 0,
    'C', 'h', 'a', 'i', 'n', 'J', 'n', 't', 'T', 'o', 'J', 'a', 'c', 'D', 'o', 't', 'S', 'o', 'l', 'v', 'e', 'r', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', '_', 'N', 'R', '_', 'J', 'L', 0,
    'J', 'n', 't', 'S', 'p', 'a', 'c', 'e', 'I', 'n', 'e', 'r', 't', 'i', 'a', 'M', 'a', 't', 'r', 'i', 'x', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'w', 'd', 'l', 's', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', '_', 'p', 'i', 'n', 'v', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', '_', 'L', 'M', 'A', 0,
    'g', 'e', 't', 'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 'a', 'l', 'I', 'n', 'e', 'r', 't', 'i', 'a', 0,
    's', 't', 'd', ':', ':', 'v', 'e', 'c', 't', 'o', 'r', '<', 'W', 'r', 'e', 'n', 'c', 'h', '>', 0,
    'C', 'h', 'a', 'i', 'n', 'J', 'n', 't', 'T', 'o', 'J', 'a', 'c', 'S', 'o', 'l', 'v', 'e', 'r', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', '_', 'N', 'R', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'd', 'S', 'o', 'l', 'v', 'e', 'r', '_', 'R', 'N', 'E', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', 0,
    'C', 'h', 'a', 'i', 'n', 'F', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'V', 'e', 'l', 0,
    'C', 'h', 'a', 'i', 'n', 'F', 'k', 'S', 'o', 'l', 'v', 'e', 'r', 'P', 'o', 's', 0,
    'M', 'u', 'l', 't', 'i', 'p', 'l', 'y', 'J', 'a', 'c', 'o', 'b', 'i', 'a', 'n', 0,
    'R', 'i', 'g', 'i', 'd', 'B', 'o', 'd', 'y', 'I', 'n', 'e', 'r', 't', 'i', 'a', 0,
    'J', 'o', 'i', 'n', 't', ':', ':', 'J', 'o', 'i', 'n', 't', 'T', 'y', 'p', 'e', 0,
    'g', 'e', 't', 'N', 'r', 'O', 'f', 'S', 'e', 'g', 'm', 'e', 'n', 't', 's', 0,
    'c', 'h', 'a', 'n', 'g', 'e', 'R', 'e', 'f', 'F', 'r', 'a', 'm', 'e', 0,
    'c', 'h', 'a', 'n', 'g', 'e', 'R', 'e', 'f', 'P', 'o', 'i', 'n', 't', 0,
    'n', 'e', 'w', 'N', 'r', 'O', 'f', 'C', 'o', 'l', 'u', 'm', 'n', 's', 0,
    'J', 'n', 't', 'T', 'o', 'C', 'o', 'r', 'i', 'o', 'l', 'i', 's', 0,
    'C', 'h', 'a', 'i', 'n', 'D', 'y', 'n', 'P', 'a', 'r', 'a', 'm', 0,
    'C', 'h', 'a', 'i', 'n', 'I', 'd', 'S', 'o', 'l', 'v', 'e', 'r', 0,
    'g', 'e', 't', 'N', 'r', 'O', 'f', 'J', 'o', 'i', 'n', 't', 's', 0,
    'g', 'e', 't', 'F', 'r', 'a', 'm', 'e', 'T', 'o', 'T', 'i', 'p', 0,
    'G', 'e', 't', 'Q', 'u', 'a', 't', 'e', 'r', 'n', 'i', 'o', 'n', 0,
    'J', 'n', 't', 'T', 'o', 'G', 'r', 'a', 'v', 'i', 't', 'y', 0,
    'g', 'e', 't', 'S', 't', 'i', 'f', 'f', 'n', 'e', 's', 's', 0,
    'D', 'H', '_', 'C', 'r', 'a', 'i', 'g', '1', '9', '8', '9', 0,
    'G', 'e', 't', 'T', 'w', 'i', 's', 't', 'D', 'o', 't', 0,
    'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 'V', 'e', 'l', 0,
    'J', 'n', 't', 'T', 'o', 'J', 'a', 'c', 'D', 'o', 't', 0,
    '_', 'e', 'p', 's', '_', 'j', 'o', 'i', 'n', 't', 's', 0,
    's', 'e', 't', 'W', 'e', 'i', 'g', 'h', 't', 'J', 'S', 0,
    's', 'e', 't', 'W', 'e', 'i', 'g', 'h', 't', 'T', 'S', 0,
    'J', 'n', 't', 'A', 'r', 'r', 'a', 'y', 'V', 'e', 'l', 0,
    'g', 'e', 't', 'T', 'y', 'p', 'e', 'N', 'a', 'm', 'e', 0,
    'J', 'o', 'i', 'n', 't', 'O', 'r', 'i', 'g', 'i', 'n', 0,
    'G', 'e', 't', 'E', 'u', 'l', 'e', 'r', 'Z', 'Y', 'X', 0,
    'G', 'e', 't', 'E', 'u', 'l', 'e', 'r', 'Z', 'Y', 'Z', 0,
    'G', 'e', 't', 'R', 'o', 't', 'A', 'n', 'g', 'l', 'e', 0,
    'R', 'e', 'v', 'e', 'r', 's', 'e', 'S', 'i', 'g', 'n', 0,
    '_', '_', 's', 'e', 't', 'i', 't', 'e', 'm', '_', '_', 0,
    '_', '_', 'g', 'e', 't', 'i', 't', 'e', 'm', '_', '_', 0,
    's', 't', 'd', ':', ':', 's', 't', 'r', 'i', 'n', 'g', 0,
    'g', 'e', 't', 'W', 'e', 'i', 'g', 'h', 't', 's', 0,
    's', 'e', 't', 'W', 'e', 'i', 'g', 'h', 't', 's', 0,
    'c', 'h', 'a', 'n', 'g', 'e', 'B', 'a', 's', 'e', 0,
    'c', 'h', 'a', 'i', 'n', '_', 'r', 'o', 'o', 't', 0,
    'g', 'e', 't', 'S', 'e', 'g', 'm', 'e', 'n', 't', 0,
    'a', 'd', 'd', 'S', 'e', 'g', 'm', 'e', 'n', 't', 0,
    's', 'e', 't', 'I', 'n', 'e', 'r', 't', 'i', 'a', 0,
    'g', 'e', 't', 'D', 'a', 'm', 'p', 'i', 'n', 'g', 0,
    'g', 'e', 't', 'I', 'n', 'e', 'r', 't', 'i', 'a', 0,
    'S', 'e', 't', 'I', 'n', 'v', 'e', 'r', 's', 'e', 0,
    'J', 'n', 't', 'T', 'o', 'M', 'a', 's', 's', 0,
    'V', 'e', 'c', 't', 'o', 'r', 'V', 'e', 'l', 0,
    'd', 'o', 'u', 'b', 'l', 'e', 'V', 'e', 'l', 0,
    'g', 'e', 't', 'O', 'p', 't', 'P', 'o', 's', 0,
    's', 'e', 't', 'O', 'p', 't', 'P', 'o', 's', 0,
    's', 'e', 't', 'L', 'a', 'm', 'b', 'd', 'a', 0,
    'C', 'a', 'r', 't', 'T', 'o', 'J', 'n', 't', 0,
    'J', 'n', 't', 'T', 'o', 'C', 'a', 'r', 't', 0,
    's', 'e', 'g', 'm', 'e', 'n', 't', 'N', 'r', 0,
    's', 'e', 't', 'C', 'o', 'l', 'u', 'm', 'n', 0,
    'g', 'e', 't', 'C', 'o', 'l', 'u', 'm', 'n', 0,
    'c', 'h', 'a', 'i', 'n', '_', 't', 'i', 'p', 0,
    'h', 'o', 'o', 'k', '_', 'n', 'a', 'm', 'e', 0,
    'r', 'o', 'o', 't', '_', 'n', 'a', 'm', 'e', 0,
    'J', 'o', 'i', 'n', 't', 'A', 'x', 'i', 's', 0,
    's', 't', 'i', 'f', 'f', 'n', 'e', 's', 's', 0,
    'T', 'r', 'a', 'n', 's', 'A', 'x', 'i', 's', 0,
    'v', '_', 'b', 'a', 's', 'e', '_', 'A', 'B', 0,
    'I', 'n', 't', 'e', 'g', 'r', 'a', 't', 'e', 0,
    'f', 'r', 'e', 'q', 'u', 'e', 'n', 'c', 'y', 0,
    'S', 'e', 't', 'T', 'o', 'Z', 'e', 'r', 'o', 0,
    'N', 'o', 'r', 'm', 'a', 'l', 'i', 'z', 'e', 0,
    'c', 'o', 'r', 'i', 'o', 'l', 'i', 's', 0,
    'T', 'w', 'i', 's', 't', 'V', 'e', 'l', 0,
    'G', 'e', 't', 'T', 'w', 'i', 's', 't', 0,
    'G', 'e', 't', 'F', 'r', 'a', 'm', 'e', 0,
    'F', 'r', 'a', 'm', 'e', 'V', 'e', 'l', 0,
    'q', '_', 'd', 'o', 't', 'd', 'o', 't', 0,
    'J', 'n', 't', 'T', 'o', 'J', 'a', 'c', 0,
    'g', 'e', 't', 'A', 'l', 'p', 'h', 'a', 0,
    's', 'e', 't', 'A', 'l', 'p', 'h', 'a', 0,
    '_', 'm', 'a', 'x', 'i', 't', 'e', 'r', 0,
    'i', 'k', 's', 'o', 'l', 'v', 'e', 'r', 0,
    'f', 'k', 's', 'o', 'l', 'v', 'e', 'r', 0,
    'q', 'd', 'o', 't', '_', 'o', 'u', 't', 0,
    's', 't', 'r', 'E', 'r', 'r', 'o', 'r', 0,
    'g', 'e', 't', 'E', 'r', 'r', 'o', 'r', 0,
    'M', 'u', 'l', 't', 'i', 'p', 'l', 'y', 0,
    'S', 'u', 'b', 't', 'r', 'a', 'c', 't', 0,
    'J', 'n', 't', 'A', 'r', 'r', 'a', 'y', 0,
    'g', 'e', 't', 'C', 'h', 'a', 'i', 'n', 0,
    'a', 'd', 'd', 'C', 'h', 'a', 'i', 'n', 0,
    'g', 'e', 't', 'J', 'o', 'i', 'n', 't', 0,
    'a', 'd', 'd', 'D', 'e', 'l', 't', 'a', 0,
    'I', 'd', 'e', 'n', 't', 'i', 't', 'y', 0,
    'R', 'o', 't', 'a', 't', 'i', 'o', 'n', 0,
    '_', '_', 'i', 'a', 'd', 'd', '_', '_', 0,
    '_', '_', 'i', 's', 'u', 'b', '_', '_', 0,
    '_', '_', 'r', 'e', 'p', 'r', '_', '_', 0,
    'g', 'r', 'a', 'v', 'i', 't', 'y', 0,
    't', 'o', 'r', 'q', 'u', 'e', 's', 0,
    'o', 'p', 't', '_', 'p', 'o', 's', 0,
    'w', 'e', 'i', 'g', 'h', 't', 's', 0,
    'S', 'o', 'l', 'v', 'e', 'r', 'I', 0,
    'n', 'e', 'w', 'S', 'i', 'z', 'e', 0,
    'c', 'o', 'l', 'u', 'm', 'n', 's', 0,
    's', 'e', 'g', 'm', 'e', 'n', 't', 0,
    'g', 'e', 't', 'M', 'a', 's', 's', 0,
    'g', 'e', 't', 'T', 'y', 'p', 'e', 0,
    'g', 'e', 't', 'N', 'a', 'm', 'e', 0,
    'd', 'a', 'm', 'p', 'i', 'n', 'g', 0,
    'i', 'n', 'e', 'r', 't', 'i', 'a', 0,
    'R', 'o', 't', 'A', 'x', 'i', 's', 0,
    '_', '_', 's', 'u', 'b', '_', '_', 0,
    '_', '_', 'a', 'd', 'd', '_', '_', 0,
    '_', '_', 'd', 'i', 'v', '_', '_', 0,
    '_', '_', 'm', 'u', 'l', '_', '_', 0,
    '_', '_', 'n', 'e', 'g', '_', '_', 0,
    'm', 'a', 't', 'r', 'i', 'x', 0,
    'r', 'o', 't', 'v', 'e', 'c', 0,
    's', 'e', 'g', '_', 'n', 'r', 0,
    'l', 'a', 'm', 'b', 'd', 'a', 0,
    'q', '_', 'i', 'n', 'i', 't', 0,
    'D', 'i', 'v', 'i', 'd', 'e', 0,
    'f', 'a', 'c', 't', 'o', 'r', 0,
    'r', 'e', 's', 'i', 'z', 'e', 0,
    'g', 'e', 't', 'C', 'O', 'G', 0,
    'o', 'r', 'i', 'g', 'i', 'n', 0,
    'o', 'f', 'f', 's', 'e', 't', 0,
    'T', 'r', 'a', 'n', 's', 'Z', 0,
    'T', 'r', 'a', 'n', 's', 'Y', 0,
    'T', 'r', 'a', 'n', 's', 'X', 0,
    'W', '_', 'a', '_', 'p', '2', 0,
    'W', '_', 'a', '_', 'p', '1', 0,
    'F', '_', 'a', '_', 'b', '2', 0,
    'F', '_', 'a', '_', 'b', '1', 0,
    'R', '_', 'a', '_', 'b', '2', 0,
    'R', '_', 'a', '_', 'b', '1', 0,
    't', 'o', 'r', 'q', 'u', 'e', 0,
    'W', 'r', 'e', 'n', 'c', 'h', 0,
    't', '_', 't', 'h', 'i', 's', 0,
    'G', 'e', 't', 'R', 'P', 'Y', 0,
    'G', 'e', 't', 'R', 'o', 't', 0,
    'D', 'o', 'R', 'o', 't', 'Z', 0,
    'D', 'o', 'R', 'o', 't', 'Y', 0,
    'D', 'o', 'R', 'o', 't', 'X', 0,
    '_', '_', 'n', 'e', '_', '_', 0,
    '_', '_', 'e', 'q', '_', '_', 0,
    'V', 'e', 'c', 't', 'o', 'r', 0,
    '_', 'g', 'r', 'a', 'v', 0,
    'f', '_', 'e', 'x', 't', 0,
    'q', '_', 'd', 'o', 't', 0,
    'q', '_', 'm', 'a', 'x', 0,
    'q', '_', 'm', 'i', 'n', 0,
    'q', '_', 'o', 'u', 't', 0,
    'p', '_', 'o', 'u', 't', 0,
    'f', 'r', 'a', 'm', 'e', 0,
    'd', 'e', 'r', 'i', 'v', 0,
    'a', 'r', 'r', 'a', 'y', 0,
    'c', 'h', 'a', 'i', 'n', 0,
    'f', '_', 't', 'i', 'p', 0,
    'j', 'o', 'i', 'n', 't', 0,
    't', 'w', 'i', 's', 't', 0,
    's', 'c', 'a', 'l', 'e', 0,
    'f', 'o', 'r', 'c', 'e', 0,
    't', 'h', 'e', 't', 'a', 0,
    'a', 'l', 'p', 'h', 'a', 0,
    'U', 'n', 'i', 't', 'Z', 0,
    'U', 'n', 'i', 't', 'Y', 0,
    'U', 'n', 'i', 't', 'X', 0,
    'g', 'a', 'm', 'm', 'a', 0,
    'p', 'i', 't', 'c', 'h', 0,
    'G', 'a', 'm', 'm', 'a', 0,
    'a', 'n', 'g', 'l', 'e', 0,
    'E', 'q', 'u', 'a', 'l', 0,
    'v', 'a', 'l', 'u', 'e', 0,
    'P', 'y', 'K', 'D', 'L', 0,
    'g', 'r', 'a', 'd', 0,
    'v', '_', 'i', 'n', 0,
    'p', '_', 'i', 'n', 0,
    'q', '_', 'i', 'n', 0,
    'd', 'e', 's', 't', 0,
    's', 'r', 'c', '2', 0,
    's', 'r', 'c', '1', 0,
    'r', 'o', 'w', 's', 0,
    'T', 'r', 'e', 'e', 0,
    'q', 'd', 'o', 't', 0,
    'p', 'o', 's', 'e', 0,
    't', 'y', 'p', 'e', 0,
    'N', 'o', 'n', 'e', 0,
    'd', 'i', 'f', 'f', 0,
    '_', 'r', 'o', 't', 0,
    '_', 'v', 'e', 'l', 0,
    'b', 'e', 't', 'a', 0,
    'a', 'l', 'f', 'a', 0,
    'a', 'x', 'i', 's', 0,
    'r', 'o', 'l', 'l', 0,
    'B', 'e', 't', 'a', 0,
    'A', 'l', 'f', 'a', 0,
    'R', 'o', 't', '2', 0,
    'N', 'o', 'r', 'm', 0,
    'j', 'a', 'c', 0,
    's', 'r', 'c', 0,
    'A', 'd', 'd', 0,
    'I', 'i', 'n', 0,
    'I', 'y', 'z', 0,
    'I', 'x', 'z', 0,
    'I', 'x', 'y', 0,
    'I', 'z', 'z', 0,
    'I', 'y', 'y', 0,
    'I', 'x', 'x', 0,
    'y', 'a', 'w', 0,
    'r', 'h', 's', 0,
    'l', 'h', 's', 0,
    'e', 'p', 's', 0,
    'a', 'r', 'g', 0,
    '_', 'M', 0,
    '_', 't', 0,
    '_', 'T', 0,
    '_', 'w', 0,
    '_', 'R', 0,
    '_', 'v', 0,
    '_', 'p', 0,
    'r', '2', 0,
    'r', '1', 0,
    'I', 'c', 0,
    'o', 'c', 0,
    'd', 't', 0,
    'D', 'H', 0,
    'Z', 'z', 0,
    'Y', 'z', 0,
    'X', 'z', 0,
    'Z', 'y', 0,
    'Y', 'y', 0,
    'X', 'y', 0,
    'Z', 'x', 0,
    'Y', 'x', 0,
    'X', 'x', 0,
    'q', 0,
    'i', 0,
    'V', 0,
    'b', 0,
};

int sipVH_PyKDL_10(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArray& a0,const  ::JntArray& a1,const  ::JntArray& a2,const std::vector< ::Wrench>& a3, ::JntArray& a4)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NNNND", new  ::JntArray(a0), sipType_JntArray, NULL, new  ::JntArray(a1), sipType_JntArray, NULL, new  ::JntArray(a2), sipType_JntArray, NULL, new std::vector< ::Wrench>(a3), sipType_std_vector_0100Wrench, NULL, &a4, sipType_JntArray, NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_9(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const double a0)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "d", a0);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_8(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArray& a0)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "N", new  ::JntArray(a0), sipType_JntArray, NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_7(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArray& a0,const  ::FrameVel& a1, ::JntArrayVel& a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NND", new  ::JntArray(a0), sipType_JntArray, NULL, new  ::FrameVel(a1), sipType_FrameVel, NULL, &a2, sipType_JntArrayVel, NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_6(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NND", new  ::JntArray(a0), sipType_JntArray, NULL, new  ::Twist(a1), sipType_Twist, NULL, &a2, sipType_JntArray, NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_5(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArray& a0,const  ::Frame& a1, ::JntArray& a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NND", new  ::JntArray(a0), sipType_JntArray, NULL, new  ::Frame(a1), sipType_Frame, NULL, &a2, sipType_JntArray, NULL);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_4(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArrayVel& a0, ::FrameVel& a1,int a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NDi", new  ::JntArrayVel(a0), sipType_JntArrayVel, NULL, &a1, sipType_FrameVel, NULL, a2);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

int sipVH_PyKDL_3(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const  ::JntArray& a0, ::Frame& a1,int a2)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "NDi", new  ::JntArray(a0), sipType_JntArray, NULL, &a1, sipType_Frame, NULL, a2);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}

void sipVH_PyKDL_2(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod)
{
    sipCallProcedureMethod(sipGILState, sipErrorHandler, sipPySelf, sipMethod, "");
}

const char* sipVH_PyKDL_1(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod, const int a0, int sipResKey)
{
    char* sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "i", a0);

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "B", sipResKey, &sipRes);

    return sipRes;
}

int sipVH_PyKDL_0(sip_gilstate_t sipGILState, sipVirtErrorHandlerFunc sipErrorHandler, sipSimpleWrapper *sipPySelf, PyObject *sipMethod)
{
    int sipRes = 0;
    PyObject *sipResObj = sipCallMethod(0, sipMethod, "");

    sipParseResultEx(sipGILState, sipErrorHandler, sipPySelf, sipMethod, sipResObj, "i", &sipRes);

    return sipRes;
}


PyDoc_STRVAR(doc_changeRefFrame, "changeRefFrame(src1: Jacobian, frame: Frame, dest: Jacobian)");

extern "C" {static PyObject *func_changeRefFrame(PyObject *,PyObject *, PyObject *);}
static PyObject *func_changeRefFrame(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Jacobian* a0;
        const  ::Frame* a1;
         ::Jacobian* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_frame,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_Jacobian, &a0, sipType_Frame, &a1, sipType_Jacobian, &a2))
        {
            changeRefFrame(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_changeRefFrame, doc_changeRefFrame);

    return NULL;
}


PyDoc_STRVAR(doc_changeBase, "changeBase(src1: Jacobian, rot: Rotation, dest: Jacobian)");

extern "C" {static PyObject *func_changeBase(PyObject *,PyObject *, PyObject *);}
static PyObject *func_changeBase(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Jacobian* a0;
        const  ::Rotation* a1;
         ::Jacobian* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_rot,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_Jacobian, &a0, sipType_Rotation, &a1, sipType_Jacobian, &a2))
        {
            changeBase(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_changeBase, doc_changeBase);

    return NULL;
}


PyDoc_STRVAR(doc_changeRefPoint, "changeRefPoint(src1: Jacobian, base_AB: Vector, dest: Jacobian)");

extern "C" {static PyObject *func_changeRefPoint(PyObject *,PyObject *, PyObject *);}
static PyObject *func_changeRefPoint(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Jacobian* a0;
        const  ::Vector* a1;
         ::Jacobian* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_base_AB,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_Jacobian, &a0, sipType_Vector, &a1, sipType_Jacobian, &a2))
        {
            changeRefPoint(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_changeRefPoint, doc_changeRefPoint);

    return NULL;
}


PyDoc_STRVAR(doc_MultiplyJacobian, "MultiplyJacobian(jac: Jacobian, src: JntArray, dest: Twist)");

extern "C" {static PyObject *func_MultiplyJacobian(PyObject *,PyObject *, PyObject *);}
static PyObject *func_MultiplyJacobian(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Jacobian* a0;
        const  ::JntArray* a1;
         ::Twist* a2;

        static const char *sipKwdList[] = {
            sipName_jac,
            sipName_src,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_Jacobian, &a0, sipType_JntArray, &a1, sipType_Twist, &a2))
        {
            MultiplyJacobian(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_MultiplyJacobian, doc_MultiplyJacobian);

    return NULL;
}


PyDoc_STRVAR(doc_Divide, "Divide(src: JntArray, factor: float, dest: JntArray)\n"
"Divide(src: JntArrayVel, factor: float, dest: JntArrayVel)\n"
"Divide(src: JntArrayVel, factor: doubleVel, dest: JntArrayVel)\n"
"Divide(src: JntSpaceInertiaMatrix, factor: float, dest: JntSpaceInertiaMatrix)");

extern "C" {static PyObject *func_Divide(PyObject *,PyObject *, PyObject *);}
static PyObject *func_Divide(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
        double a1;
         ::JntArray* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ9", sipType_JntArray, &a0, &a1, sipType_JntArray, &a2))
        {
            Divide(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        double a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ9", sipType_JntArrayVel, &a0, &a1, sipType_JntArrayVel, &a2))
        {
            Divide(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::doubleVel* a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArrayVel, &a0, sipType_doubleVel, &a1, sipType_JntArrayVel, &a2))
        {
            Divide(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;
        double a1;
         ::JntSpaceInertiaMatrix* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ9", sipType_JntSpaceInertiaMatrix, &a0, &a1, sipType_JntSpaceInertiaMatrix, &a2))
        {
            Divide(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Divide, doc_Divide);

    return NULL;
}


PyDoc_STRVAR(doc_Multiply, "Multiply(src: JntArray, factor: float, dest: JntArray)\n"
"Multiply(src: JntArrayVel, factor: float, dest: JntArrayVel)\n"
"Multiply(src: JntArrayVel, factor: doubleVel, dest: JntArrayVel)\n"
"Multiply(src: JntSpaceInertiaMatrix, factor: float, dest: JntSpaceInertiaMatrix)\n"
"Multiply(src: JntSpaceInertiaMatrix, vec: JntArray, dest: JntArray)");

extern "C" {static PyObject *func_Multiply(PyObject *,PyObject *, PyObject *);}
static PyObject *func_Multiply(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
        double a1;
         ::JntArray* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ9", sipType_JntArray, &a0, &a1, sipType_JntArray, &a2))
        {
            Multiply(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        double a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ9", sipType_JntArrayVel, &a0, &a1, sipType_JntArrayVel, &a2))
        {
            Multiply(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::doubleVel* a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArrayVel, &a0, sipType_doubleVel, &a1, sipType_JntArrayVel, &a2))
        {
            Multiply(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;
        double a1;
         ::JntSpaceInertiaMatrix* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_factor,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9dJ9", sipType_JntSpaceInertiaMatrix, &a0, &a1, sipType_JntSpaceInertiaMatrix, &a2))
        {
            Multiply(*a0,a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;
        const  ::JntArray* a1;
         ::JntArray* a2;

        static const char *sipKwdList[] = {
            sipName_src,
            sipName_vec,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntSpaceInertiaMatrix, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2))
        {
            Multiply(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Multiply, doc_Multiply);

    return NULL;
}


PyDoc_STRVAR(doc_Subtract, "Subtract(src1: JntArray, src2: JntArray, dest: JntArray)\n"
"Subtract(src1: JntArrayVel, src2: JntArrayVel, dest: JntArrayVel)\n"
"Subtract(src1: JntArrayVel, src2: JntArray, dest: JntArrayVel)\n"
"Subtract(src1: JntSpaceInertiaMatrix, src2: JntSpaceInertiaMatrix, dest: JntSpaceInertiaMatrix)");

extern "C" {static PyObject *func_Subtract(PyObject *,PyObject *, PyObject *);}
static PyObject *func_Subtract(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
        const  ::JntArray* a1;
         ::JntArray* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArray, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2))
        {
            Subtract(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::JntArrayVel* a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArrayVel, &a0, sipType_JntArrayVel, &a1, sipType_JntArrayVel, &a2))
        {
            Subtract(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::JntArray* a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArrayVel, &a0, sipType_JntArray, &a1, sipType_JntArrayVel, &a2))
        {
            Subtract(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;
        const  ::JntSpaceInertiaMatrix* a1;
         ::JntSpaceInertiaMatrix* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntSpaceInertiaMatrix, &a0, sipType_JntSpaceInertiaMatrix, &a1, sipType_JntSpaceInertiaMatrix, &a2))
        {
            Subtract(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Subtract, doc_Subtract);

    return NULL;
}


PyDoc_STRVAR(doc_Add, "Add(src1: JntArray, src2: JntArray, dest: JntArray)\n"
"Add(src1: JntArrayVel, src2: JntArrayVel, dest: JntArrayVel)\n"
"Add(src1: JntArrayVel, src2: JntArray, dest: JntArrayVel)\n"
"Add(src1: JntSpaceInertiaMatrix, src2: JntSpaceInertiaMatrix, dest: JntSpaceInertiaMatrix)");

extern "C" {static PyObject *func_Add(PyObject *,PyObject *, PyObject *);}
static PyObject *func_Add(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
        const  ::JntArray* a1;
         ::JntArray* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArray, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2))
        {
            Add(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::JntArrayVel* a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArrayVel, &a0, sipType_JntArrayVel, &a1, sipType_JntArrayVel, &a2))
        {
            Add(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::JntArray* a1;
         ::JntArrayVel* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntArrayVel, &a0, sipType_JntArray, &a1, sipType_JntArrayVel, &a2))
        {
            Add(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;
        const  ::JntSpaceInertiaMatrix* a1;
         ::JntSpaceInertiaMatrix* a2;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_dest,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9J9", sipType_JntSpaceInertiaMatrix, &a0, sipType_JntSpaceInertiaMatrix, &a1, sipType_JntSpaceInertiaMatrix, &a2))
        {
            Add(*a0,*a1,*a2);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Add, doc_Add);

    return NULL;
}


PyDoc_STRVAR(doc_addDelta, "addDelta(a: Vector, da: Vector, dt: float = 1) -> Vector\n"
"addDelta(a: Rotation, da: Vector, dt: float = 1) -> Rotation\n"
"addDelta(a: Frame, da: Twist, dt: float = 1) -> Frame\n"
"addDelta(a: Twist, da: Twist, dt: float = 1) -> Twist\n"
"addDelta(a: Wrench, da: Wrench, dt: float = 1) -> Wrench\n"
"addDelta(a: doubleVel, da: doubleVel, dt: float = 1) -> doubleVel\n"
"addDelta(a: VectorVel, da: VectorVel, dt: float = 1) -> VectorVel\n"
"addDelta(a: RotationVel, da: VectorVel, dt: float = 1) -> RotationVel\n"
"addDelta(a: FrameVel, da: TwistVel, dt: float = 1) -> FrameVel");

extern "C" {static PyObject *func_addDelta(PyObject *,PyObject *, PyObject *);}
static PyObject *func_addDelta(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::Vector* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Vector, &a0, sipType_Vector, &a1, &a2))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Rotation* a0;
        const  ::Vector* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Rotation, &a0, sipType_Vector, &a1, &a2))
        {
             ::Rotation*sipRes;

            sipRes = new  ::Rotation(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Rotation,NULL);
        }
    }

    {
        const  ::Frame* a0;
        const  ::Twist* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Frame, &a0, sipType_Twist, &a1, &a2))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    {
        const  ::Twist* a0;
        const  ::Twist* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Twist, &a0, sipType_Twist, &a1, &a2))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    {
        const  ::Wrench* a0;
        const  ::Wrench* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Wrench, &a0, sipType_Wrench, &a1, &a2))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    {
        const  ::doubleVel* a0;
        const  ::doubleVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_doubleVel, &a0, sipType_doubleVel, &a1, &a2))
        {
             ::doubleVel*sipRes;

            sipRes = new  ::doubleVel(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_VectorVel, &a0, sipType_VectorVel, &a1, &a2))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::RotationVel* a0;
        const  ::VectorVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_RotationVel, &a0, sipType_VectorVel, &a1, &a2))
        {
             ::RotationVel*sipRes;

            sipRes = new  ::RotationVel(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_RotationVel,NULL);
        }
    }

    {
        const  ::FrameVel* a0;
        const  ::TwistVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_da,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_FrameVel, &a0, sipType_TwistVel, &a1, &a2))
        {
             ::FrameVel*sipRes;

            sipRes = new  ::FrameVel(addDelta(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_addDelta, doc_addDelta);

    return NULL;
}


PyDoc_STRVAR(doc_diff, "diff(a: Vector, b: Vector, dt: float = 1) -> Vector\n"
"diff(R_a_b1: Rotation, R_a_b2: Rotation, dt: float = 1) -> Vector\n"
"diff(F_a_b1: Frame, F_a_b2: Frame, dt: float = 1) -> Twist\n"
"diff(a: Twist, b: Twist, dt: float = 1) -> Twist\n"
"diff(W_a_p1: Wrench, W_a_p2: Wrench, dt: float = 1) -> Wrench\n"
"diff(a: doubleVel, b: doubleVel, dt: float = 1) -> doubleVel\n"
"diff(a: VectorVel, b: VectorVel, dt: float = 1) -> VectorVel\n"
"diff(a: RotationVel, b: RotationVel, dt: float = 1) -> VectorVel\n"
"diff(a: FrameVel, b: FrameVel, dt: float = 1) -> TwistVel");

extern "C" {static PyObject *func_diff(PyObject *,PyObject *, PyObject *);}
static PyObject *func_diff(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::Vector* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Vector, &a0, sipType_Vector, &a1, &a2))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Rotation* a0;
        const  ::Rotation* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_R_a_b1,
            sipName_R_a_b2,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Rotation, &a0, sipType_Rotation, &a1, &a2))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        const  ::Frame* a0;
        const  ::Frame* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_F_a_b1,
            sipName_F_a_b2,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Frame, &a0, sipType_Frame, &a1, &a2))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    {
        const  ::Twist* a0;
        const  ::Twist* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Twist, &a0, sipType_Twist, &a1, &a2))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    {
        const  ::Wrench* a0;
        const  ::Wrench* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_W_a_p1,
            sipName_W_a_p2,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Wrench, &a0, sipType_Wrench, &a1, &a2))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    {
        const  ::doubleVel* a0;
        const  ::doubleVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_doubleVel, &a0, sipType_doubleVel, &a1, &a2))
        {
             ::doubleVel*sipRes;

            sipRes = new  ::doubleVel(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_VectorVel, &a0, sipType_VectorVel, &a1, &a2))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::RotationVel* a0;
        const  ::RotationVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_RotationVel, &a0, sipType_RotationVel, &a1, &a2))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::FrameVel* a0;
        const  ::FrameVel* a1;
        double a2 = 1;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_dt,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_FrameVel, &a0, sipType_FrameVel, &a1, &a2))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel(diff(*a0,*a1,a2));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_diff, doc_diff);

    return NULL;
}


PyDoc_STRVAR(doc_Equal, "Equal(a: Vector, b: Vector, eps: float = epsilon) -> bool\n"
"Equal(a: Rotation, b: Rotation, eps: float = epsilon) -> bool\n"
"Equal(a: Frame, b: Frame, eps: float = epsilon) -> bool\n"
"Equal(a: Twist, b: Twist, eps: float = epsilon) -> bool\n"
"Equal(a: Wrench, b: Wrench, eps: float = epsilon) -> bool\n"
"Equal(src1: JntArray, src2: JntArray, eps: float = epsilon) -> bool\n"
"Equal(src1: JntArrayVel, src2: JntArrayVel, eps: float = epsilon) -> bool\n"
"Equal(r1: doubleVel, r2: doubleVel, eps: float = epsilon) -> bool\n"
"Equal(r1: VectorVel, r2: VectorVel, eps: float = epsilon) -> bool\n"
"Equal(r1: Vector, r2: VectorVel, eps: float = epsilon) -> bool\n"
"Equal(r1: VectorVel, r2: Vector, eps: float = epsilon) -> bool\n"
"Equal(r1: RotationVel, r2: RotationVel, eps: float = epsilon) -> bool\n"
"Equal(r1: Rotation, r2: RotationVel, eps: float = epsilon) -> bool\n"
"Equal(r1: RotationVel, r2: Rotation, eps: float = epsilon) -> bool\n"
"Equal(r1: FrameVel, r2: FrameVel, eps: float = epsilon) -> bool\n"
"Equal(r1: Frame, r2: FrameVel, eps: float = epsilon) -> bool\n"
"Equal(r1: FrameVel, r2: Frame, eps: float = epsilon) -> bool\n"
"Equal(a: TwistVel, b: TwistVel, eps: float = epsilon) -> bool\n"
"Equal(a: Twist, b: TwistVel, eps: float = epsilon) -> bool\n"
"Equal(a: TwistVel, b: Twist, eps: float = epsilon) -> bool\n"
"Equal(src1: JntSpaceInertiaMatrix, src2: JntSpaceInertiaMatrix, eps: float = epsilon) -> bool");

extern "C" {static PyObject *func_Equal(PyObject *,PyObject *, PyObject *);}
static PyObject *func_Equal(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::Vector* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Vector, &a0, sipType_Vector, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Rotation* a0;
        const  ::Rotation* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Rotation, &a0, sipType_Rotation, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Frame* a0;
        const  ::Frame* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Frame, &a0, sipType_Frame, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Twist* a0;
        const  ::Twist* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Twist, &a0, sipType_Twist, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Wrench* a0;
        const  ::Wrench* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Wrench, &a0, sipType_Wrench, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::JntArray* a0;
        const  ::JntArray* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_JntArray, &a0, sipType_JntArray, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::JntArrayVel* a0;
        const  ::JntArrayVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_JntArrayVel, &a0, sipType_JntArrayVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::doubleVel* a0;
        const  ::doubleVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_doubleVel, &a0, sipType_doubleVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_VectorVel, &a0, sipType_VectorVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Vector* a0;
        const  ::VectorVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Vector, &a0, sipType_VectorVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::Vector* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_VectorVel, &a0, sipType_Vector, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::RotationVel* a0;
        const  ::RotationVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_RotationVel, &a0, sipType_RotationVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Rotation* a0;
        const  ::RotationVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Rotation, &a0, sipType_RotationVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::RotationVel* a0;
        const  ::Rotation* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_RotationVel, &a0, sipType_Rotation, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::FrameVel* a0;
        const  ::FrameVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_FrameVel, &a0, sipType_FrameVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Frame* a0;
        const  ::FrameVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Frame, &a0, sipType_FrameVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::FrameVel* a0;
        const  ::Frame* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_r1,
            sipName_r2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_FrameVel, &a0, sipType_Frame, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::TwistVel* a0;
        const  ::TwistVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_TwistVel, &a0, sipType_TwistVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::Twist* a0;
        const  ::TwistVel* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_Twist, &a0, sipType_TwistVel, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::TwistVel* a0;
        const  ::Twist* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_a,
            sipName_b,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_TwistVel, &a0, sipType_Twist, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;
        const  ::JntSpaceInertiaMatrix* a1;
        double a2 = epsilon;

        static const char *sipKwdList[] = {
            sipName_src1,
            sipName_src2,
            sipName_eps,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9|d", sipType_JntSpaceInertiaMatrix, &a0, sipType_JntSpaceInertiaMatrix, &a1, &a2))
        {
            bool sipRes;

            sipRes = Equal(*a0,*a1,a2);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_Equal, doc_Equal);

    return NULL;
}


PyDoc_STRVAR(doc_dot, "dot(lhs: Vector, rhs: Vector) -> float\n"
"dot(lhs: Twist, rhs: Wrench) -> float\n"
"dot(rhs: Wrench, lhs: Twist) -> float\n"
"dot(lhs: VectorVel, rhs: VectorVel) -> doubleVel\n"
"dot(lhs: VectorVel, rhs: Vector) -> doubleVel\n"
"dot(lhs: Vector, rhs: VectorVel) -> doubleVel");

extern "C" {static PyObject *func_dot(PyObject *,PyObject *, PyObject *);}
static PyObject *func_dot(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
        const  ::Vector* a1;

        static const char *sipKwdList[] = {
            sipName_lhs,
            sipName_rhs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_Vector, &a0, sipType_Vector, &a1))
        {
            double sipRes;

            sipRes = dot(*a0,*a1);

            return PyFloat_FromDouble(sipRes);
        }
    }

    {
        const  ::Twist* a0;
        const  ::Wrench* a1;

        static const char *sipKwdList[] = {
            sipName_lhs,
            sipName_rhs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_Twist, &a0, sipType_Wrench, &a1))
        {
            double sipRes;

            sipRes = dot(*a0,*a1);

            return PyFloat_FromDouble(sipRes);
        }
    }

    {
        const  ::Wrench* a0;
        const  ::Twist* a1;

        static const char *sipKwdList[] = {
            sipName_rhs,
            sipName_lhs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_Wrench, &a0, sipType_Twist, &a1))
        {
            double sipRes;

            sipRes = dot(*a0,*a1);

            return PyFloat_FromDouble(sipRes);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;

        static const char *sipKwdList[] = {
            sipName_lhs,
            sipName_rhs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_VectorVel, &a0, sipType_VectorVel, &a1))
        {
             ::doubleVel*sipRes;

            sipRes = new  ::doubleVel(dot(*a0,*a1));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::Vector* a1;

        static const char *sipKwdList[] = {
            sipName_lhs,
            sipName_rhs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_VectorVel, &a0, sipType_Vector, &a1))
        {
             ::doubleVel*sipRes;

            sipRes = new  ::doubleVel(dot(*a0,*a1));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    {
        const  ::Vector* a0;
        const  ::VectorVel* a1;

        static const char *sipKwdList[] = {
            sipName_lhs,
            sipName_rhs,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9J9", sipType_Vector, &a0, sipType_VectorVel, &a1))
        {
             ::doubleVel*sipRes;

            sipRes = new  ::doubleVel(dot(*a0,*a1));

            return sipConvertFromNewType(sipRes,sipType_doubleVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_dot, doc_dot);

    return NULL;
}


PyDoc_STRVAR(doc_SetToZero, "SetToZero(v: Vector)\n"
"SetToZero(v: Twist)\n"
"SetToZero(v: Wrench)\n"
"SetToZero(array: JntArray)\n"
"SetToZero(array: JntArrayVel)\n"
"SetToZero(jac: Jacobian)\n"
"SetToZero(v: TwistVel)\n"
"SetToZero(matrix: JntSpaceInertiaMatrix)");

extern "C" {static PyObject *func_SetToZero(PyObject *,PyObject *, PyObject *);}
static PyObject *func_SetToZero(PyObject *,PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
         ::Vector* a0;

        static const char *sipKwdList[] = {
            sipName_v,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_Vector, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::Twist* a0;

        static const char *sipKwdList[] = {
            sipName_v,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_Twist, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::Wrench* a0;

        static const char *sipKwdList[] = {
            sipName_v,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_Wrench, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::JntArray* a0;

        static const char *sipKwdList[] = {
            sipName_array,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_JntArray, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::JntArrayVel* a0;

        static const char *sipKwdList[] = {
            sipName_array,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_JntArrayVel, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::Jacobian* a0;

        static const char *sipKwdList[] = {
            sipName_jac,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_Jacobian, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::TwistVel* a0;

        static const char *sipKwdList[] = {
            sipName_v,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_TwistVel, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    {
         ::JntSpaceInertiaMatrix* a0;

        static const char *sipKwdList[] = {
            sipName_matrix,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "J9", sipType_JntSpaceInertiaMatrix, &a0))
        {
            SetToZero(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoFunction(sipParseErr, sipName_SetToZero, doc_SetToZero);

    return NULL;
}
static sipEnumTypeDef enumTypes[] = {
    {{-1, 0, 0, SIP_TYPE_ENUM, sipNameNr_Joint__JointType, {0}, 0}, sipNameNr_JointType, 25, NULL},
};


/*
 * This defines each type in this module.
 */
sipTypeDef *sipExportedTypes_PyKDL[] = {
    &sipTypeDef_PyKDL_Chain.ctd_base,
    &sipTypeDef_PyKDL_ChainDynParam.ctd_base,
    &sipTypeDef_PyKDL_ChainFkSolverPos.ctd_base,
    &sipTypeDef_PyKDL_ChainFkSolverPos_recursive.ctd_base,
    &sipTypeDef_PyKDL_ChainFkSolverVel.ctd_base,
    &sipTypeDef_PyKDL_ChainFkSolverVel_recursive.ctd_base,
    &sipTypeDef_PyKDL_ChainIdSolver.ctd_base,
    &sipTypeDef_PyKDL_ChainIdSolver_RNE.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverPos.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverPos_LMA.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverPos_NR.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverPos_NR_JL.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel_pinv.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel_pinv_givens.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel_pinv_nso.ctd_base,
    &sipTypeDef_PyKDL_ChainIkSolverVel_wdls.ctd_base,
    &sipTypeDef_PyKDL_ChainJntToJacDotSolver.ctd_base,
    &sipTypeDef_PyKDL_ChainJntToJacSolver.ctd_base,
    &sipTypeDef_PyKDL_Frame.ctd_base,
    &sipTypeDef_PyKDL_FrameVel.ctd_base,
    &sipTypeDef_PyKDL_Jacobian.ctd_base,
    &sipTypeDef_PyKDL_JntArray.ctd_base,
    &sipTypeDef_PyKDL_JntArrayVel.ctd_base,
    &sipTypeDef_PyKDL_JntSpaceInertiaMatrix.ctd_base,
    &sipTypeDef_PyKDL_Joint.ctd_base,
    &enumTypes[0].etd_base,
    &sipTypeDef_PyKDL_RigidBodyInertia.ctd_base,
    &sipTypeDef_PyKDL_Rotation.ctd_base,
    &sipTypeDef_PyKDL_RotationVel.ctd_base,
    &sipTypeDef_PyKDL_RotationalInertia.ctd_base,
    &sipTypeDef_PyKDL_Segment.ctd_base,
    &sipTypeDef_PyKDL_SolverI.ctd_base,
    &sipTypeDef_PyKDL_Tree.ctd_base,
    &sipTypeDef_PyKDL_Twist.ctd_base,
    &sipTypeDef_PyKDL_TwistVel.ctd_base,
    &sipTypeDef_PyKDL_Vector.ctd_base,
    &sipTypeDef_PyKDL_VectorVel.ctd_base,
    &sipTypeDef_PyKDL_Wrench.ctd_base,
    &sipTypeDef_PyKDL_doubleVel.ctd_base,
    &sipTypeDef_PyKDL_std_string.mtd_base,
    &sipTypeDef_PyKDL_std_vector_0100Wrench.mtd_base,
};


/*
 * These define each typedef in this module.
 */
static sipTypedefDef typedefsTable[] = {
    {"doubleVel::doubleVel", "Rall1d<double>"},
};


/* Define the module's license. */
static sipLicenseDef module_license = {
    "LGPL",
    "Ruben Smits",
    "2014",
    "ruben@intermodalics.eu"
};


/* This defines this module. */
sipExportedModuleDef sipModuleAPI_PyKDL = {
    0,
    SIP_API_MINOR_NR,
    sipNameNr_PyKDL,
    0,
    sipStrings_PyKDL,
    NULL,
    NULL,
    42,
    sipExportedTypes_PyKDL,
    NULL,
    0,
    NULL,
    1,
    typedefsTable,
    NULL,
    NULL,
    {NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL},
    &module_license,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL,
    NULL
};


/* The SIP API and the APIs of any imported modules. */
const sipAPIDef *sipAPI_PyKDL;


/* The Python module initialisation function. */
#if PY_MAJOR_VERSION >= 3
#define SIP_MODULE_ENTRY        PyInit_PyKDL
#define SIP_MODULE_TYPE         PyObject *
#define SIP_MODULE_DISCARD(r)   Py_DECREF(r)
#define SIP_MODULE_RETURN(r)    return (r)
#else
#define SIP_MODULE_ENTRY        initPyKDL
#define SIP_MODULE_TYPE         void
#define SIP_MODULE_DISCARD(r)
#define SIP_MODULE_RETURN(r)    return
#endif

#if defined(SIP_STATIC_MODULE)
extern "C" SIP_MODULE_TYPE SIP_MODULE_ENTRY()
#else
PyMODINIT_FUNC SIP_MODULE_ENTRY()
#endif
{
    static PyMethodDef sip_methods[] = {
        {SIP_MLNAME_CAST(sipName_changeRefFrame), (PyCFunction)func_changeRefFrame, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_changeRefFrame)},
        {SIP_MLNAME_CAST(sipName_changeBase), (PyCFunction)func_changeBase, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_changeBase)},
        {SIP_MLNAME_CAST(sipName_changeRefPoint), (PyCFunction)func_changeRefPoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_changeRefPoint)},
        {SIP_MLNAME_CAST(sipName_MultiplyJacobian), (PyCFunction)func_MultiplyJacobian, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_MultiplyJacobian)},
        {SIP_MLNAME_CAST(sipName_Divide), (PyCFunction)func_Divide, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Divide)},
        {SIP_MLNAME_CAST(sipName_Multiply), (PyCFunction)func_Multiply, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Multiply)},
        {SIP_MLNAME_CAST(sipName_Subtract), (PyCFunction)func_Subtract, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Subtract)},
        {SIP_MLNAME_CAST(sipName_Add), (PyCFunction)func_Add, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Add)},
        {SIP_MLNAME_CAST(sipName_addDelta), (PyCFunction)func_addDelta, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_addDelta)},
        {SIP_MLNAME_CAST(sipName_diff), (PyCFunction)func_diff, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_diff)},
        {SIP_MLNAME_CAST(sipName_Equal), (PyCFunction)func_Equal, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Equal)},
        {SIP_MLNAME_CAST(sipName_dot), (PyCFunction)func_dot, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_dot)},
        {SIP_MLNAME_CAST(sipName_SetToZero), (PyCFunction)func_SetToZero, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_SetToZero)},
        {0, 0, 0, 0}
    };

#if PY_MAJOR_VERSION >= 3
    static PyModuleDef sip_module_def = {
        PyModuleDef_HEAD_INIT,
        "PyKDL",
        NULL,
        -1,
        sip_methods,
        NULL,
        NULL,
        NULL,
        NULL
    };
#endif

    PyObject *sipModule, *sipModuleDict;
    PyObject *sip_sipmod, *sip_capiobj;

    /* Initialise the module and get it's dictionary. */
#if PY_MAJOR_VERSION >= 3
    sipModule = PyModule_Create(&sip_module_def);
#elif PY_VERSION_HEX >= 0x02050000
    sipModule = Py_InitModule(sipName_PyKDL, sip_methods);
#else
    sipModule = Py_InitModule(const_cast<char *>(sipName_PyKDL), sip_methods);
#endif

    if (sipModule == NULL)
        SIP_MODULE_RETURN(NULL);

    sipModuleDict = PyModule_GetDict(sipModule);

    /* Get the SIP module's API. */
#if PY_VERSION_HEX >= 0x02050000
    sip_sipmod = PyImport_ImportModule(SIP_MODULE_NAME);
#else
    sip_sipmod = PyImport_ImportModule(const_cast<char *>(SIP_MODULE_NAME));
#endif

    if (sip_sipmod == NULL)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }

    sip_capiobj = PyDict_GetItemString(PyModule_GetDict(sip_sipmod), "_C_API");
    Py_DECREF(sip_sipmod);

#if defined(SIP_USE_PYCAPSULE)
    if (sip_capiobj == NULL || !PyCapsule_CheckExact(sip_capiobj))
#else
    if (sip_capiobj == NULL || !PyCObject_Check(sip_capiobj))
#endif
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }

#if defined(SIP_USE_PYCAPSULE)
    sipAPI_PyKDL = reinterpret_cast<const sipAPIDef *>(PyCapsule_GetPointer(sip_capiobj, SIP_MODULE_NAME "._C_API"));
#else
    sipAPI_PyKDL = reinterpret_cast<const sipAPIDef *>(PyCObject_AsVoidPtr(sip_capiobj));
#endif

#if defined(SIP_USE_PYCAPSULE)
    if (sipAPI_PyKDL == NULL)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(NULL);
    }
#endif

    /* Export the module and publish it's API. */
    if (sipExportModule(&sipModuleAPI_PyKDL,SIP_API_MAJOR_NR,SIP_API_MINOR_NR,0) < 0)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(0);
    }
    /* Initialise the module now all its dependencies have been set up. */
    if (sipInitModule(&sipModuleAPI_PyKDL,sipModuleDict) < 0)
    {
        SIP_MODULE_DISCARD(sipModule);
        SIP_MODULE_RETURN(0);
    }

    SIP_MODULE_RETURN(sipModule);
}

#line 27 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <vector>
#line 2498 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"

#line 352 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 2505 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"


extern "C" {static void assign_std_vector_0100Wrench(void *, SIP_SSIZE_T, void *);}
static void assign_std_vector_0100Wrench(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast<std::vector< ::Wrench> *>(sipDst)[sipDstIdx] = *reinterpret_cast<std::vector< ::Wrench> *>(sipSrc);
}


extern "C" {static void *array_std_vector_0100Wrench(SIP_SSIZE_T);}
static void *array_std_vector_0100Wrench(SIP_SSIZE_T sipNrElem)
{
    return new std::vector< ::Wrench>[sipNrElem];
}


extern "C" {static void *copy_std_vector_0100Wrench(const void *, SIP_SSIZE_T);}
static void *copy_std_vector_0100Wrench(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new std::vector< ::Wrench>(reinterpret_cast<const std::vector< ::Wrench> *>(sipSrc)[sipSrcIdx]);
}


/* Call the mapped type's destructor. */
extern "C" {static void release_std_vector_0100Wrench(void *, int);}
static void release_std_vector_0100Wrench(void *ptr, int)
{
    delete reinterpret_cast<std::vector< ::Wrench> *>(ptr);
}



extern "C" {static int convertTo_std_vector_0100Wrench(PyObject *, void **, int *, PyObject *);}
static int convertTo_std_vector_0100Wrench(PyObject *sipPy,void **sipCppPtrV,int *sipIsErr,PyObject *sipTransferObj)
{
    std::vector< ::Wrench> **sipCppPtr = reinterpret_cast<std::vector< ::Wrench> **>(sipCppPtrV);

#line 60 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    // Check if type is compatible
    if (!sipIsErr) {
        // Must be any iterable
        PyObject *i = PyObject_GetIter(sipPy);
        bool iterable = (i != NULL);
        Py_XDECREF(i);
        return iterable;
    }

    // Iterate over the object
    PyObject *iterator = PyObject_GetIter(sipPy);
    PyObject *item;

    std::vector<Wrench> *V = new std::vector<Wrench>();

    while ((item = PyIter_Next(iterator)))
    {
        if (!sipCanConvertToInstance(item, sipClass_Wrench, SIP_NOT_NONE)) {
            PyErr_Format(PyExc_TypeError, "object in iterable cannot be converted to Wrench");
            *sipIsErr = 1;
            break;
        }

        int state;
        Wrench* p = reinterpret_cast<Wrench*>(
             sipConvertToInstance(item, sipClass_Wrench, 0, SIP_NOT_NONE, &state, sipIsErr));

        if (!*sipIsErr)
            V->push_back(*p);

        sipReleaseInstance(p, sipClass_Wrench, state);
        Py_DECREF(item);
    }

    Py_DECREF(iterator);

    if (*sipIsErr) {
        delete V;
        return 0;
    }

    *sipCppPtr = V;
    return sipGetState(sipTransferObj);
#line 2587 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
}


extern "C" {static PyObject *convertFrom_std_vector_0100Wrench(void *, PyObject *);}
static PyObject *convertFrom_std_vector_0100Wrench(void *sipCppV, PyObject *sipTransferObj)
{
   std::vector< ::Wrench> *sipCpp = reinterpret_cast<std::vector< ::Wrench> *>(sipCppV);

#line 31 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    PyObject *l = PyList_New(sipCpp -> size());

    // Create the Python list of the correct length.
    if (!l)
        return NULL;

    // Go through each element in the C++ instance and convert it to a
    // wrapped P2d.
    for (int i = 0; i < (int)sipCpp->size(); ++i) {
        Wrench *cpp = new Wrench(sipCpp->at(i));
        PyObject *pobj = sipConvertFromInstance(cpp, sipClass_Wrench, sipTransferObj);

        // Get the Python wrapper for the Type instance, creating a new
        // one if necessary, and handle any ownership transfer.
        if (!pobj) {
            // There was an error so garbage collect the Python list.
            Py_DECREF(l);
            return NULL;
        }

        // Add the wrapper to the list.
        PyList_SET_ITEM(l, i, pobj);
    }

    // Return the Python list.
    return l;
#line 2623 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
}


sipMappedTypeDef sipTypeDef_PyKDL_std_vector_0100Wrench = {
    {
        -1,
        0,
        0,
        SIP_TYPE_MAPPED,
        sipNameNr_292,     /* std::vector<Wrench> */
        {0},
        0
    },
    {
        -1,
        {0, 0, 1},
        0, 0,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    assign_std_vector_0100Wrench,
    array_std_vector_0100Wrench,
    copy_std_vector_0100Wrench,
    release_std_vector_0100Wrench,
    convertTo_std_vector_0100Wrench,
    convertFrom_std_vector_0100Wrench
};

#line 65 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
#include <kdl/chaindynparam.hpp>
using namespace KDL;
#line 2656 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"

#line 241 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 2661 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 2667 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 280 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 2671 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
#include <kdl/jntspaceinertiamatrix.hpp>
using namespace KDL;
#line 2675 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_ChainDynParam_JntToCoriolis, "JntToCoriolis(self, q: JntArray, q_dot: JntArray, coriolis: JntArray) -> int");

extern "C" {static PyObject *meth_ChainDynParam_JntToCoriolis(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainDynParam_JntToCoriolis(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
        const  ::JntArray* a1;
         ::JntArray* a2;
         ::ChainDynParam *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
            sipName_q_dot,
            sipName_coriolis,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainDynParam, &sipCpp, sipType_JntArray, &a0, sipType_JntArray, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = sipCpp->JntToCoriolis(*a0,*a1,*a2);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainDynParam, sipName_JntToCoriolis, doc_ChainDynParam_JntToCoriolis);

    return NULL;
}


PyDoc_STRVAR(doc_ChainDynParam_JntToMass, "JntToMass(self, q: JntArray, H: JntSpaceInertiaMatrix) -> int");

extern "C" {static PyObject *meth_ChainDynParam_JntToMass(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainDynParam_JntToMass(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
         ::JntSpaceInertiaMatrix* a1;
         ::ChainDynParam *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
            sipName_H,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9", &sipSelf, sipType_ChainDynParam, &sipCpp, sipType_JntArray, &a0, sipType_JntSpaceInertiaMatrix, &a1))
        {
            int sipRes;

            sipRes = sipCpp->JntToMass(*a0,*a1);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainDynParam, sipName_JntToMass, doc_ChainDynParam_JntToMass);

    return NULL;
}


PyDoc_STRVAR(doc_ChainDynParam_JntToGravity, "JntToGravity(self, q: JntArray, gravity: JntArray) -> int");

extern "C" {static PyObject *meth_ChainDynParam_JntToGravity(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainDynParam_JntToGravity(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
         ::JntArray* a1;
         ::ChainDynParam *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
            sipName_gravity,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9", &sipSelf, sipType_ChainDynParam, &sipCpp, sipType_JntArray, &a0, sipType_JntArray, &a1))
        {
            int sipRes;

            sipRes = sipCpp->JntToGravity(*a0,*a1);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainDynParam, sipName_JntToGravity, doc_ChainDynParam_JntToGravity);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainDynParam(void *, int);}
static void release_ChainDynParam(void *sipCppV, int)
{
    delete reinterpret_cast< ::ChainDynParam *>(sipCppV);
}


extern "C" {static void dealloc_ChainDynParam(sipSimpleWrapper *);}
static void dealloc_ChainDynParam(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainDynParam(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_ChainDynParam(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainDynParam(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::ChainDynParam *sipCpp = 0;

    {
        const  ::Chain* a0;
         ::Vector* a1;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName__grav,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_Chain, &a0, sipType_Vector, &a1))
        {
            sipCpp = new  ::ChainDynParam(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::ChainDynParam* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainDynParam, &a0))
        {
            sipCpp = new  ::ChainDynParam(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_ChainDynParam[] = {
    {SIP_MLNAME_CAST(sipName_JntToCoriolis), (PyCFunction)meth_ChainDynParam_JntToCoriolis, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainDynParam_JntToCoriolis)},
    {SIP_MLNAME_CAST(sipName_JntToGravity), (PyCFunction)meth_ChainDynParam_JntToGravity, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainDynParam_JntToGravity)},
    {SIP_MLNAME_CAST(sipName_JntToMass), (PyCFunction)meth_ChainDynParam_JntToMass, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainDynParam_JntToMass)}
};

PyDoc_STRVAR(doc_ChainDynParam, "\1ChainDynParam(chain: Chain, _grav: Vector)\n"
"ChainDynParam(ChainDynParam)");


sipClassTypeDef sipTypeDef_PyKDL_ChainDynParam = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainDynParam,
        {0},
        0
    },
    {
        sipNameNr_ChainDynParam,
        {0, 0, 1},
        3, methods_ChainDynParam,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainDynParam,
    -1,
    -1,
    0,
    0,
    init_type_ChainDynParam,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainDynParam,
    0,
    0,
    0,
    release_ChainDynParam,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 26 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
#include <kdl/jntspaceinertiamatrix.hpp>
using namespace KDL;
#line 2904 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"



PyDoc_STRVAR(doc_JntSpaceInertiaMatrix_resize, "resize(self, newSize: int)");

extern "C" {static PyObject *meth_JntSpaceInertiaMatrix_resize(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_JntSpaceInertiaMatrix_resize(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
         ::JntSpaceInertiaMatrix *sipCpp;

        static const char *sipKwdList[] = {
            sipName_newSize,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bu", &sipSelf, sipType_JntSpaceInertiaMatrix, &sipCpp, &a0))
        {
            sipCpp->resize(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntSpaceInertiaMatrix, sipName_resize, doc_JntSpaceInertiaMatrix_resize);

    return NULL;
}


PyDoc_STRVAR(doc_JntSpaceInertiaMatrix_rows, "rows(self) -> int");

extern "C" {static PyObject *meth_JntSpaceInertiaMatrix_rows(PyObject *, PyObject *);}
static PyObject *meth_JntSpaceInertiaMatrix_rows(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntSpaceInertiaMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntSpaceInertiaMatrix, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->rows();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntSpaceInertiaMatrix, sipName_rows, doc_JntSpaceInertiaMatrix_rows);

    return NULL;
}


PyDoc_STRVAR(doc_JntSpaceInertiaMatrix_columns, "columns(self) -> int");

extern "C" {static PyObject *meth_JntSpaceInertiaMatrix_columns(PyObject *, PyObject *);}
static PyObject *meth_JntSpaceInertiaMatrix_columns(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntSpaceInertiaMatrix *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_JntSpaceInertiaMatrix, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->columns();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntSpaceInertiaMatrix, sipName_columns, doc_JntSpaceInertiaMatrix_columns);

    return NULL;
}


extern "C" {static PyObject *slot_JntSpaceInertiaMatrix___ne__(PyObject *,PyObject *);}
static PyObject *slot_JntSpaceInertiaMatrix___ne__(PyObject *sipSelf,PyObject *sipArg)
{
     ::JntSpaceInertiaMatrix *sipCpp = reinterpret_cast< ::JntSpaceInertiaMatrix *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntSpaceInertiaMatrix));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::JntSpaceInertiaMatrix* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_JntSpaceInertiaMatrix, &a0))
        {
            bool sipRes;

            sipRes = !operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, ne_slot, sipType_JntSpaceInertiaMatrix, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_JntSpaceInertiaMatrix___eq__(PyObject *,PyObject *);}
static PyObject *slot_JntSpaceInertiaMatrix___eq__(PyObject *sipSelf,PyObject *sipArg)
{
     ::JntSpaceInertiaMatrix *sipCpp = reinterpret_cast< ::JntSpaceInertiaMatrix *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntSpaceInertiaMatrix));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::JntSpaceInertiaMatrix* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_JntSpaceInertiaMatrix, &a0))
        {
            bool sipRes;

            sipRes = operator==((*sipCpp), *a0);

            return PyBool_FromLong(sipRes);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, eq_slot, sipType_JntSpaceInertiaMatrix, sipSelf, sipArg);
}


extern "C" {static PyObject *slot_JntSpaceInertiaMatrix___getitem__(PyObject *,PyObject *);}
static PyObject *slot_JntSpaceInertiaMatrix___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
     ::JntSpaceInertiaMatrix *sipCpp = reinterpret_cast< ::JntSpaceInertiaMatrix *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_JntSpaceInertiaMatrix));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1T", &PyTuple_Type, &a0))
        {
            double sipRes = 0;

#line 39 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/dynamics.sip"
    int i,j;
    PyArg_ParseTuple(a0,"ii",&i,&j);
    if (i < 0 || j < 0 || i > (int)sipCpp->rows() || j >= (int)sipCpp->columns()) {
        PyErr_SetString(PyExc_IndexError, "Inertia index out of range");
        return NULL;
    }
    sipRes=(*sipCpp)(i,j);
#line 3085 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_JntSpaceInertiaMatrix, sipName___getitem__, NULL);

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_JntSpaceInertiaMatrix(void *, int);}
static void release_JntSpaceInertiaMatrix(void *sipCppV, int)
{
    delete reinterpret_cast< ::JntSpaceInertiaMatrix *>(sipCppV);
}


extern "C" {static void assign_JntSpaceInertiaMatrix(void *, SIP_SSIZE_T, void *);}
static void assign_JntSpaceInertiaMatrix(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::JntSpaceInertiaMatrix *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::JntSpaceInertiaMatrix *>(sipSrc);
}


extern "C" {static void *array_JntSpaceInertiaMatrix(SIP_SSIZE_T);}
static void *array_JntSpaceInertiaMatrix(SIP_SSIZE_T sipNrElem)
{
    return new  ::JntSpaceInertiaMatrix[sipNrElem];
}


extern "C" {static void *copy_JntSpaceInertiaMatrix(const void *, SIP_SSIZE_T);}
static void *copy_JntSpaceInertiaMatrix(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::JntSpaceInertiaMatrix(reinterpret_cast<const  ::JntSpaceInertiaMatrix *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_JntSpaceInertiaMatrix(sipSimpleWrapper *);}
static void dealloc_JntSpaceInertiaMatrix(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_JntSpaceInertiaMatrix(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_JntSpaceInertiaMatrix(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_JntSpaceInertiaMatrix(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::JntSpaceInertiaMatrix *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::JntSpaceInertiaMatrix();

            return sipCpp;
        }
    }

    {
        int a0;

        static const char *sipKwdList[] = {
            sipName_size,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "i", &a0))
        {
            sipCpp = new  ::JntSpaceInertiaMatrix(a0);

            return sipCpp;
        }
    }

    {
        const  ::JntSpaceInertiaMatrix* a0;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_JntSpaceInertiaMatrix, &a0))
        {
            sipCpp = new  ::JntSpaceInertiaMatrix(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_JntSpaceInertiaMatrix[] = {
    {(void *)slot_JntSpaceInertiaMatrix___ne__, ne_slot},
    {(void *)slot_JntSpaceInertiaMatrix___eq__, eq_slot},
    {(void *)slot_JntSpaceInertiaMatrix___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_JntSpaceInertiaMatrix[] = {
    {SIP_MLNAME_CAST(sipName_columns), meth_JntSpaceInertiaMatrix_columns, METH_VARARGS, SIP_MLDOC_CAST(doc_JntSpaceInertiaMatrix_columns)},
    {SIP_MLNAME_CAST(sipName_resize), (PyCFunction)meth_JntSpaceInertiaMatrix_resize, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_JntSpaceInertiaMatrix_resize)},
    {SIP_MLNAME_CAST(sipName_rows), meth_JntSpaceInertiaMatrix_rows, METH_VARARGS, SIP_MLDOC_CAST(doc_JntSpaceInertiaMatrix_rows)}
};

PyDoc_STRVAR(doc_JntSpaceInertiaMatrix, "\1JntSpaceInertiaMatrix()\n"
"JntSpaceInertiaMatrix(size: int)\n"
"JntSpaceInertiaMatrix(arg: JntSpaceInertiaMatrix)");


sipClassTypeDef sipTypeDef_PyKDL_JntSpaceInertiaMatrix = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_JntSpaceInertiaMatrix,
        {0},
        0
    },
    {
        sipNameNr_JntSpaceInertiaMatrix,
        {0, 0, 1},
        3, methods_JntSpaceInertiaMatrix,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_JntSpaceInertiaMatrix,
    -1,
    -1,
    0,
    slots_JntSpaceInertiaMatrix,
    init_type_JntSpaceInertiaMatrix,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_JntSpaceInertiaMatrix,
    assign_JntSpaceInertiaMatrix,
    array_JntSpaceInertiaMatrix,
    copy_JntSpaceInertiaMatrix,
    release_JntSpaceInertiaMatrix,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 207 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 3260 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"

#line 44 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 3265 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 281 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 3271 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 3275 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_TwistVel_value, "value(self) -> Twist");

extern "C" {static PyObject *meth_TwistVel_value(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_value(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->value());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_value, doc_TwistVel_value);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_deriv, "deriv(self) -> Twist");

extern "C" {static PyObject *meth_TwistVel_deriv(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_deriv(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->deriv());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_deriv, doc_TwistVel_deriv);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_Zero, "Zero() -> TwistVel");

extern "C" {static PyObject *meth_TwistVel_Zero(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel( ::TwistVel::Zero());

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_Zero, doc_TwistVel_Zero);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_ReverseSign, "ReverseSign(self)");

extern "C" {static PyObject *meth_TwistVel_ReverseSign(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_ReverseSign(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
         ::TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
            sipCpp->ReverseSign();

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_ReverseSign, doc_TwistVel_ReverseSign);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_RefPoint, "RefPoint(self, v_base_AB: VectorVel) -> TwistVel");

extern "C" {static PyObject *meth_TwistVel_RefPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_TwistVel_RefPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::VectorVel* a0;
         ::TwistVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_v_base_AB,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_TwistVel, &sipCpp, sipType_VectorVel, &a0))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel(sipCpp->RefPoint(*a0));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_RefPoint, doc_TwistVel_RefPoint);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_GetTwist, "GetTwist(self) -> Twist");

extern "C" {static PyObject *meth_TwistVel_GetTwist(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_GetTwist(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->GetTwist());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_GetTwist, doc_TwistVel_GetTwist);

    return NULL;
}


PyDoc_STRVAR(doc_TwistVel_GetTwistDot, "GetTwistDot(self) -> Twist");

extern "C" {static PyObject *meth_TwistVel_GetTwistDot(PyObject *, PyObject *);}
static PyObject *meth_TwistVel_GetTwistDot(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_TwistVel, &sipCpp))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->GetTwistDot());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_TwistVel, sipName_GetTwistDot, doc_TwistVel_GetTwistDot);

    return NULL;
}


extern "C" {static PyObject *slot_TwistVel___neg__(PyObject *);}
static PyObject *slot_TwistVel___neg__(PyObject *sipSelf)
{
     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_TwistVel));

    if (!sipCpp)
        return 0;


    {
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel(-(*sipCpp));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    return 0;
}


extern "C" {static PyObject *slot_TwistVel___mul__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_TwistVel, &a0, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 * a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        double a0;
        const  ::TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_TwistVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const  ::TwistVel* a0;
        const  ::doubleVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_TwistVel, &a0, sipType_doubleVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_TwistVel___div__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___div__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel* a0;
        double a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9d", sipType_TwistVel, &a0, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 / a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const  ::TwistVel* a0;
        const  ::doubleVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_TwistVel, &a0, sipType_doubleVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 / *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, div_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_TwistVel___add__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel* a0;
        const  ::TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_TwistVel, &a0, sipType_TwistVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, add_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_TwistVel___sub__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___sub__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel* a0;
        const  ::TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_TwistVel, &a0, sipType_TwistVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 - *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, sub_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_TwistVel___iadd__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___iadd__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_TwistVel)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_TwistVel));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_TwistVel, &a0))
        {
            sipCpp-> ::TwistVel::operator+=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


extern "C" {static PyObject *slot_TwistVel___isub__(PyObject *,PyObject *);}
static PyObject *slot_TwistVel___isub__(PyObject *sipSelf,PyObject *sipArg)
{
    if (!PyObject_TypeCheck(sipSelf, sipTypeAsPyTypeObject(sipType_TwistVel)))
    {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }

     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_TwistVel));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        const  ::TwistVel* a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1J9", sipType_TwistVel, &a0))
        {
            sipCpp-> ::TwistVel::operator-=(*a0);

            Py_INCREF(sipSelf);
            return sipSelf;
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    PyErr_Clear();

    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


/* Call the instance's destructor. */
extern "C" {static void release_TwistVel(void *, int);}
static void release_TwistVel(void *sipCppV, int)
{
    delete reinterpret_cast< ::TwistVel *>(sipCppV);
}


extern "C" {static PyObject *pickle_TwistVel(void *);}
static PyObject *pickle_TwistVel(void *sipCppV)
{
     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipCppV);
    PyObject *sipRes;

#line 233 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
    const sipTypeDef *vectorvel_type = sipFindType("VectorVel");
    sipRes = Py_BuildValue("OO", sipConvertFromType(&(sipCpp->vel), vectorvel_type, Py_None),
                                 sipConvertFromType(&(sipCpp->rot), vectorvel_type, Py_None));
#line 3751 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_TwistVel(void *, SIP_SSIZE_T, void *);}
static void assign_TwistVel(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::TwistVel *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::TwistVel *>(sipSrc);
}


extern "C" {static void *array_TwistVel(SIP_SSIZE_T);}
static void *array_TwistVel(SIP_SSIZE_T sipNrElem)
{
    return new  ::TwistVel[sipNrElem];
}


extern "C" {static void *copy_TwistVel(const void *, SIP_SSIZE_T);}
static void *copy_TwistVel(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::TwistVel(reinterpret_cast<const  ::TwistVel *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_TwistVel(sipSimpleWrapper *);}
static void dealloc_TwistVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_TwistVel(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_TwistVel(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_TwistVel(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::TwistVel *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::TwistVel();

            return sipCpp;
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::VectorVel* a1;

        static const char *sipKwdList[] = {
            sipName__vel,
            sipName__rot,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_VectorVel, &a0, sipType_VectorVel, &a1))
        {
            sipCpp = new  ::TwistVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::Twist* a0;
        const  ::Twist* a1;

        static const char *sipKwdList[] = {
            sipName_p,
            sipName_v,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_Twist, &a0, sipType_Twist, &a1))
        {
            sipCpp = new  ::TwistVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::Twist* a0;

        static const char *sipKwdList[] = {
            sipName_p,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Twist, &a0))
        {
            sipCpp = new  ::TwistVel(*a0);

            return sipCpp;
        }
    }

    {
        const  ::TwistVel* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_TwistVel, &a0))
        {
            sipCpp = new  ::TwistVel(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_TwistVel[] = {
    {(void *)slot_TwistVel___neg__, neg_slot},
    {(void *)slot_TwistVel___mul__, mul_slot},
    {(void *)slot_TwistVel___div__, div_slot},
    {(void *)slot_TwistVel___add__, add_slot},
    {(void *)slot_TwistVel___sub__, sub_slot},
    {(void *)slot_TwistVel___iadd__, iadd_slot},
    {(void *)slot_TwistVel___isub__, isub_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_TwistVel[] = {
    {SIP_MLNAME_CAST(sipName_GetTwist), meth_TwistVel_GetTwist, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_GetTwist)},
    {SIP_MLNAME_CAST(sipName_GetTwistDot), meth_TwistVel_GetTwistDot, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_GetTwistDot)},
    {SIP_MLNAME_CAST(sipName_RefPoint), (PyCFunction)meth_TwistVel_RefPoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_TwistVel_RefPoint)},
    {SIP_MLNAME_CAST(sipName_ReverseSign), meth_TwistVel_ReverseSign, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_ReverseSign)},
    {SIP_MLNAME_CAST(sipName_Zero), meth_TwistVel_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_Zero)},
    {SIP_MLNAME_CAST(sipName_deriv), meth_TwistVel_deriv, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_deriv)},
    {SIP_MLNAME_CAST(sipName_value), meth_TwistVel_value, METH_VARARGS, SIP_MLDOC_CAST(doc_TwistVel_value)}
};


extern "C" {static PyObject *varget_TwistVel_rot(void *, PyObject *, PyObject *);}
static PyObject *varget_TwistVel_rot(void *sipSelf, PyObject *sipPySelf, PyObject *)
{
    PyObject *sipPy;
     ::VectorVel*sipVal;
     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipSelf);

    sipPy = sipGetReference(sipPySelf, -2);

    if (sipPy)
        return sipPy;

    sipVal = &sipCpp->rot;

    sipPy = sipConvertFromType(sipVal, sipType_VectorVel, NULL);

    if (sipPy)
    {
        sipKeepReference(sipPy, -1, sipPySelf);
        sipKeepReference(sipPySelf, -2, sipPy);
    }

    return sipPy;
}


extern "C" {static int varset_TwistVel_rot(void *, PyObject *, PyObject *);}
static int varset_TwistVel_rot(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::VectorVel*sipVal;
     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::VectorVel *>(sipForceConvertToType(sipPy,sipType_VectorVel,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->rot = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_TwistVel_vel(void *, PyObject *, PyObject *);}
static PyObject *varget_TwistVel_vel(void *sipSelf, PyObject *sipPySelf, PyObject *)
{
    PyObject *sipPy;
     ::VectorVel*sipVal;
     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipSelf);

    sipPy = sipGetReference(sipPySelf, -4);

    if (sipPy)
        return sipPy;

    sipVal = &sipCpp->vel;

    sipPy = sipConvertFromType(sipVal, sipType_VectorVel, NULL);

    if (sipPy)
    {
        sipKeepReference(sipPy, -3, sipPySelf);
        sipKeepReference(sipPySelf, -4, sipPy);
    }

    return sipPy;
}


extern "C" {static int varset_TwistVel_vel(void *, PyObject *, PyObject *);}
static int varset_TwistVel_vel(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::VectorVel*sipVal;
     ::TwistVel *sipCpp = reinterpret_cast< ::TwistVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::VectorVel *>(sipForceConvertToType(sipPy,sipType_VectorVel,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->vel = *sipVal;

    return 0;
}

sipVariableDef variables_TwistVel[] = {
    {InstanceVariable, sipName_rot, (PyMethodDef *)varget_TwistVel_rot, (PyMethodDef *)varset_TwistVel_rot, NULL, NULL},
    {InstanceVariable, sipName_vel, (PyMethodDef *)varget_TwistVel_vel, (PyMethodDef *)varset_TwistVel_vel, NULL, NULL},
};

PyDoc_STRVAR(doc_TwistVel, "\1TwistVel()\n"
"TwistVel(_vel: VectorVel, _rot: VectorVel)\n"
"TwistVel(p: Twist, v: Twist)\n"
"TwistVel(p: Twist)\n"
"TwistVel(TwistVel)");


sipClassTypeDef sipTypeDef_PyKDL_TwistVel = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_TwistVel,
        {0},
        0
    },
    {
        sipNameNr_TwistVel,
        {0, 0, 1},
        7, methods_TwistVel,
        0, 0,
        2, variables_TwistVel,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_TwistVel,
    -1,
    -1,
    0,
    slots_TwistVel,
    init_type_TwistVel,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_TwistVel,
    assign_TwistVel,
    array_TwistVel,
    copy_TwistVel,
    release_TwistVel,
    0,
    0,
    0,
    0,
    pickle_TwistVel,
    0,
    0
};

#line 159 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 4048 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"

#line 100 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 4053 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 44 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 4057 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 201 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 4063 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 281 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 4069 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 26 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 4075 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"
#line 207 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
#include <kdl/framevel.hpp>
using namespace KDL;
#line 4079 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"


PyDoc_STRVAR(doc_FrameVel_value, "value(self) -> Frame");

extern "C" {static PyObject *meth_FrameVel_value(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_value(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->value());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_value, doc_FrameVel_value);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_deriv, "deriv(self) -> Twist");

extern "C" {static PyObject *meth_FrameVel_deriv(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_deriv(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->deriv());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_deriv, doc_FrameVel_deriv);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_Identity, "Identity() -> FrameVel");

extern "C" {static PyObject *meth_FrameVel_Identity(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_Identity(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::FrameVel*sipRes;

            sipRes = new  ::FrameVel( ::FrameVel::Identity());

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_Identity, doc_FrameVel_Identity);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_Inverse, "Inverse(self) -> FrameVel\n"
"Inverse(self, arg: VectorVel) -> VectorVel\n"
"Inverse(self, arg: Vector) -> VectorVel\n"
"Inverse(self, arg: TwistVel) -> TwistVel\n"
"Inverse(self, arg: Twist) -> TwistVel");

extern "C" {static PyObject *meth_FrameVel_Inverse(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_FrameVel_Inverse(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::FrameVel *sipCpp;

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, NULL, NULL, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
             ::FrameVel*sipRes;

            sipRes = new  ::FrameVel(sipCpp->Inverse());

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    {
        const  ::VectorVel* a0;
        const  ::FrameVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_FrameVel, &sipCpp, sipType_VectorVel, &a0))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::Vector* a0;
        const  ::FrameVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_FrameVel, &sipCpp, sipType_Vector, &a0))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
        const  ::TwistVel* a0;
        const  ::FrameVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_FrameVel, &sipCpp, sipType_TwistVel, &a0))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const  ::Twist* a0;
        const  ::FrameVel *sipCpp;

        static const char *sipKwdList[] = {
            sipName_arg,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_FrameVel, &sipCpp, sipType_Twist, &a0))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel(sipCpp->Inverse(*a0));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_Inverse, doc_FrameVel_Inverse);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_GetFrame, "GetFrame(self) -> Frame");

extern "C" {static PyObject *meth_FrameVel_GetFrame(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_GetFrame(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->GetFrame());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_GetFrame, doc_FrameVel_GetFrame);

    return NULL;
}


PyDoc_STRVAR(doc_FrameVel_GetTwist, "GetTwist(self) -> Twist");

extern "C" {static PyObject *meth_FrameVel_GetTwist(PyObject *, PyObject *);}
static PyObject *meth_FrameVel_GetTwist(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::FrameVel *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_FrameVel, &sipCpp))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->GetTwist());

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_FrameVel, sipName_GetTwist, doc_FrameVel_GetTwist);

    return NULL;
}


extern "C" {static PyObject *slot_FrameVel___mul__(PyObject *,PyObject *);}
static PyObject *slot_FrameVel___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::FrameVel* a0;
        const  ::VectorVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_VectorVel, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
         ::FrameVel* a0;
        const  ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_Vector, &a1))
        {
             ::VectorVel*sipRes;

            sipRes = new  ::VectorVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_VectorVel,NULL);
        }
    }

    {
         ::FrameVel* a0;
        const  ::TwistVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_TwistVel, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
         ::FrameVel* a0;
        const  ::Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_Twist, &a1))
        {
             ::TwistVel*sipRes;

            sipRes = new  ::TwistVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_TwistVel,NULL);
        }
    }

    {
        const  ::FrameVel* a0;
        const  ::FrameVel* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_FrameVel, &a1))
        {
             ::FrameVel*sipRes;

            sipRes = new  ::FrameVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    {
        const  ::FrameVel* a0;
        const  ::Frame* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_FrameVel, &a0, sipType_Frame, &a1))
        {
             ::FrameVel*sipRes;

            sipRes = new  ::FrameVel((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_FrameVel,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


/* Call the instance's destructor. */
extern "C" {static void release_FrameVel(void *, int);}
static void release_FrameVel(void *sipCppV, int)
{
    delete reinterpret_cast< ::FrameVel *>(sipCppV);
}


extern "C" {static PyObject *pickle_FrameVel(void *);}
static PyObject *pickle_FrameVel(void *sipCppV)
{
     ::FrameVel *sipCpp = reinterpret_cast< ::FrameVel *>(sipCppV);
    PyObject *sipRes;

#line 191 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/framevel.sip"
    const sipTypeDef *vectorvel_type = sipFindType("VectorVel");
    const sipTypeDef *rotationvel_type = sipFindType("RotationVel");
    sipRes = Py_BuildValue("OO", sipConvertFromType(&(sipCpp->M), rotationvel_type, Py_None),
                                 sipConvertFromType(&(sipCpp->p), vectorvel_type, Py_None));
#line 4445 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart0.cpp"

    return sipRes;
}


extern "C" {static void assign_FrameVel(void *, SIP_SSIZE_T, void *);}
static void assign_FrameVel(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::FrameVel *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::FrameVel *>(sipSrc);
}


extern "C" {static void *array_FrameVel(SIP_SSIZE_T);}
static void *array_FrameVel(SIP_SSIZE_T sipNrElem)
{
    return new  ::FrameVel[sipNrElem];
}


extern "C" {static void *copy_FrameVel(const void *, SIP_SSIZE_T);}
static void *copy_FrameVel(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::FrameVel(reinterpret_cast<const  ::FrameVel *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_FrameVel(sipSimpleWrapper *);}
static void dealloc_FrameVel(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_FrameVel(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_FrameVel(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_FrameVel(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::FrameVel *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::FrameVel();

            return sipCpp;
        }
    }

    {
        const  ::Frame* a0;

        static const char *sipKwdList[] = {
            sipName__T,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Frame, &a0))
        {
            sipCpp = new  ::FrameVel(*a0);

            return sipCpp;
        }
    }

    {
        const  ::Frame* a0;
        const  ::Twist* a1;

        static const char *sipKwdList[] = {
            sipName__T,
            sipName__t,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_Frame, &a0, sipType_Twist, &a1))
        {
            sipCpp = new  ::FrameVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::RotationVel* a0;
        const  ::VectorVel* a1;

        static const char *sipKwdList[] = {
            sipName__M,
            sipName__p,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9", sipType_RotationVel, &a0, sipType_VectorVel, &a1))
        {
            sipCpp = new  ::FrameVel(*a0,*a1);

            return sipCpp;
        }
    }

    {
        const  ::FrameVel* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_FrameVel, &a0))
        {
            sipCpp = new  ::FrameVel(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_FrameVel[] = {
    {(void *)slot_FrameVel___mul__, mul_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_FrameVel[] = {
    {SIP_MLNAME_CAST(sipName_GetFrame), meth_FrameVel_GetFrame, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_GetFrame)},
    {SIP_MLNAME_CAST(sipName_GetTwist), meth_FrameVel_GetTwist, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_GetTwist)},
    {SIP_MLNAME_CAST(sipName_Identity), meth_FrameVel_Identity, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_Identity)},
    {SIP_MLNAME_CAST(sipName_Inverse), (PyCFunction)meth_FrameVel_Inverse, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_FrameVel_Inverse)},
    {SIP_MLNAME_CAST(sipName_deriv), meth_FrameVel_deriv, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_deriv)},
    {SIP_MLNAME_CAST(sipName_value), meth_FrameVel_value, METH_VARARGS, SIP_MLDOC_CAST(doc_FrameVel_value)}
};


extern "C" {static PyObject *varget_FrameVel_M(void *, PyObject *, PyObject *);}
static PyObject *varget_FrameVel_M(void *sipSelf, PyObject *sipPySelf, PyObject *)
{
    PyObject *sipPy;
     ::RotationVel*sipVal;
     ::FrameVel *sipCpp = reinterpret_cast< ::FrameVel *>(sipSelf);

    sipPy = sipGetReference(sipPySelf, -6);

    if (sipPy)
        return sipPy;

    sipVal = &sipCpp->M;

    sipPy = sipConvertFromType(sipVal, sipType_RotationVel, NULL);

    if (sipPy)
    {
        sipKeepReference(sipPy, -5, sipPySelf);
        sipKeepReference(sipPySelf, -6, sipPy);
    }

    return sipPy;
}


extern "C" {static int varset_FrameVel_M(void *, PyObject *, PyObject *);}
static int varset_FrameVel_M(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::RotationVel*sipVal;
     ::FrameVel *sipCpp = reinterpret_cast< ::FrameVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::RotationVel *>(sipForceConvertToType(sipPy,sipType_RotationVel,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->M = *sipVal;

    return 0;
}


extern "C" {static PyObject *varget_FrameVel_p(void *, PyObject *, PyObject *);}
static PyObject *varget_FrameVel_p(void *sipSelf, PyObject *sipPySelf, PyObject *)
{
    PyObject *sipPy;
     ::VectorVel*sipVal;
     ::FrameVel *sipCpp = reinterpret_cast< ::FrameVel *>(sipSelf);

    sipPy = sipGetReference(sipPySelf, -8);

    if (sipPy)
        return sipPy;

    sipVal = &sipCpp->p;

    sipPy = sipConvertFromType(sipVal, sipType_VectorVel, NULL);

    if (sipPy)
    {
        sipKeepReference(sipPy, -7, sipPySelf);
        sipKeepReference(sipPySelf, -8, sipPy);
    }

    return sipPy;
}


extern "C" {static int varset_FrameVel_p(void *, PyObject *, PyObject *);}
static int varset_FrameVel_p(void *sipSelf, PyObject *sipPy, PyObject *)
{
     ::VectorVel*sipVal;
     ::FrameVel *sipCpp = reinterpret_cast< ::FrameVel *>(sipSelf);

    int sipIsErr = 0;

    sipVal = reinterpret_cast< ::VectorVel *>(sipForceConvertToType(sipPy,sipType_VectorVel,NULL,SIP_NOT_NONE,NULL,&sipIsErr));

    if (sipIsErr)
        return -1;

    sipCpp->p = *sipVal;

    return 0;
}

sipVariableDef variables_FrameVel[] = {
    {InstanceVariable, sipName_M, (PyMethodDef *)varget_FrameVel_M, (PyMethodDef *)varset_FrameVel_M, NULL, NULL},
    {InstanceVariable, sipName_p, (PyMethodDef *)varget_FrameVel_p, (PyMethodDef *)varset_FrameVel_p, NULL, NULL},
};

PyDoc_STRVAR(doc_FrameVel, "\1FrameVel()\n"
"FrameVel(_T: Frame)\n"
"FrameVel(_T: Frame, _t: Twist)\n"
"FrameVel(_M: RotationVel, _p: VectorVel)\n"
"FrameVel(FrameVel)");


sipClassTypeDef sipTypeDef_PyKDL_FrameVel = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_FrameVel,
        {0},
        0
    },
    {
        sipNameNr_FrameVel,
        {0, 0, 1},
        6, methods_FrameVel,
        0, 0,
        2, variables_FrameVel,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_FrameVel,
    -1,
    -1,
    0,
    slots_FrameVel,
    init_type_FrameVel,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_FrameVel,
    assign_FrameVel,
    array_FrameVel,
    copy_FrameVel,
    release_FrameVel,
    0,
    0,
    0,
    0,
    pickle_FrameVel,
    0,
    0
};

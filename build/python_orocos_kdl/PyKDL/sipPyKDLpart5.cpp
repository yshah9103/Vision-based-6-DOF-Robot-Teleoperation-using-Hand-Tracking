/*
 * Module code.
 *
 * Generated by SIP 4.19.7
 */

#include "sipAPIPyKDL.h"

#line 261 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/tree.hpp>
using namespace KDL;
#line 13 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

#line 21 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 17 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 241 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 21 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 211 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 26 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Tree_addSegment, "addSegment(self, segment: Segment, hook_name: object) -> bool");

extern "C" {static PyObject *meth_Tree_addSegment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Tree_addSegment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment* a0;
        const  ::std::string* a1;
        int a1State = 0;
         ::Tree *sipCpp;

        static const char *sipKwdList[] = {
            sipName_segment,
            sipName_hook_name,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J1", &sipSelf, sipType_Tree, &sipCpp, sipType_Segment, &a0, sipType_std_string,&a1, &a1State))
        {
            bool sipRes;

            sipRes = sipCpp->addSegment(*a0,*a1);
            sipReleaseType(const_cast< ::std::string *>(a1),sipType_std_string,a1State);

            return PyBool_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_addSegment, doc_Tree_addSegment);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getNrOfJoints, "getNrOfJoints(self) -> int");

extern "C" {static PyObject *meth_Tree_getNrOfJoints(PyObject *, PyObject *);}
static PyObject *meth_Tree_getNrOfJoints(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Tree *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Tree, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfJoints();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getNrOfJoints, doc_Tree_getNrOfJoints);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getNrOfSegments, "getNrOfSegments(self) -> int");

extern "C" {static PyObject *meth_Tree_getNrOfSegments(PyObject *, PyObject *);}
static PyObject *meth_Tree_getNrOfSegments(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Tree *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Tree, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfSegments();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getNrOfSegments, doc_Tree_getNrOfSegments);

    return NULL;
}


PyDoc_STRVAR(doc_Tree_getChain, "getChain(self, chain_root: object, chain_tip: object) -> Chain");

extern "C" {static PyObject *meth_Tree_getChain(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Tree_getChain(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::std::string* a0;
        int a0State = 0;
        const  ::std::string* a1;
        int a1State = 0;
        const  ::Tree *sipCpp;

        static const char *sipKwdList[] = {
            sipName_chain_root,
            sipName_chain_tip,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ1J1", &sipSelf, sipType_Tree, &sipCpp, sipType_std_string,&a0, &a0State, sipType_std_string,&a1, &a1State))
        {
             ::Chain*sipRes = 0;

#line 271 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    Chain* chain = new Chain();
    sipCpp->getChain(*a0, *a1, *chain);
    sipRes = chain;
#line 150 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
            sipReleaseType(const_cast< ::std::string *>(a0),sipType_std_string,a0State);
            sipReleaseType(const_cast< ::std::string *>(a1),sipType_std_string,a1State);

            return sipConvertFromNewType(sipRes,sipType_Chain,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Tree, sipName_getChain, doc_Tree_getChain);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_Tree(void *, int);}
static void release_Tree(void *sipCppV, int)
{
    delete reinterpret_cast< ::Tree *>(sipCppV);
}


extern "C" {static void assign_Tree(void *, SIP_SSIZE_T, void *);}
static void assign_Tree(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Tree *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Tree *>(sipSrc);
}


extern "C" {static void *array_Tree(SIP_SSIZE_T);}
static void *array_Tree(SIP_SSIZE_T sipNrElem)
{
    return new  ::Tree[sipNrElem];
}


extern "C" {static void *copy_Tree(const void *, SIP_SSIZE_T);}
static void *copy_Tree(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Tree(reinterpret_cast<const  ::Tree *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Tree(sipSimpleWrapper *);}
static void dealloc_Tree(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Tree(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Tree(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Tree(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Tree *sipCpp = 0;

    {
        const  ::std::string& a0def = "root";
        const  ::std::string* a0 = &a0def;
        int a0State = 0;

        static const char *sipKwdList[] = {
            sipName_root_name,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|J1", sipType_std_string,&a0, &a0State))
        {
            sipCpp = new  ::Tree(*a0);
            sipReleaseType(const_cast< ::std::string *>(a0),sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
        const  ::Tree* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_Tree, &a0))
        {
            sipCpp = new  ::Tree(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_Tree[] = {
    {SIP_MLNAME_CAST(sipName_addSegment), (PyCFunction)meth_Tree_addSegment, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Tree_addSegment)},
    {SIP_MLNAME_CAST(sipName_getChain), (PyCFunction)meth_Tree_getChain, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Tree_getChain)},
    {SIP_MLNAME_CAST(sipName_getNrOfJoints), meth_Tree_getNrOfJoints, METH_VARARGS, SIP_MLDOC_CAST(doc_Tree_getNrOfJoints)},
    {SIP_MLNAME_CAST(sipName_getNrOfSegments), meth_Tree_getNrOfSegments, METH_VARARGS, SIP_MLDOC_CAST(doc_Tree_getNrOfSegments)}
};

PyDoc_STRVAR(doc_Tree, "\1Tree(root_name: object = \"root\")\n"
"Tree(Tree)");


sipClassTypeDef sipTypeDef_PyKDL_Tree = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Tree,
        {0},
        0
    },
    {
        sipNameNr_Tree,
        {0, 0, 1},
        4, methods_Tree,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Tree,
    -1,
    -1,
    0,
    0,
    init_type_Tree,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Tree,
    assign_Tree,
    array_Tree,
    copy_Tree,
    release_Tree,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 241 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 307 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

#line 211 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 313 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Chain_addSegment, "addSegment(self, segment: Segment)");

extern "C" {static PyObject *meth_Chain_addSegment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Chain_addSegment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment* a0;
         ::Chain *sipCpp;

        static const char *sipKwdList[] = {
            sipName_segment,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Chain, &sipCpp, sipType_Segment, &a0))
        {
            sipCpp->addSegment(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_addSegment, doc_Chain_addSegment);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_addChain, "addChain(self, chain: Chain)");

extern "C" {static PyObject *meth_Chain_addChain(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Chain_addChain(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Chain* a0;
         ::Chain *sipCpp;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Chain, &sipCpp, sipType_Chain, &a0))
        {
            sipCpp->addChain(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_addChain, doc_Chain_addChain);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getNrOfJoints, "getNrOfJoints(self) -> int");

extern "C" {static PyObject *meth_Chain_getNrOfJoints(PyObject *, PyObject *);}
static PyObject *meth_Chain_getNrOfJoints(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Chain, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfJoints();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getNrOfJoints, doc_Chain_getNrOfJoints);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getNrOfSegments, "getNrOfSegments(self) -> int");

extern "C" {static PyObject *meth_Chain_getNrOfSegments(PyObject *, PyObject *);}
static PyObject *meth_Chain_getNrOfSegments(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Chain *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Chain, &sipCpp))
        {
            uint sipRes;

            sipRes = sipCpp->getNrOfSegments();

            return PyLong_FromUnsignedLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getNrOfSegments, doc_Chain_getNrOfSegments);

    return NULL;
}


PyDoc_STRVAR(doc_Chain_getSegment, "getSegment(self, nr: int) -> Segment");

extern "C" {static PyObject *meth_Chain_getSegment(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Chain_getSegment(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        uint a0;
        const  ::Chain *sipCpp;

        static const char *sipKwdList[] = {
            sipName_nr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bu", &sipSelf, sipType_Chain, &sipCpp, &a0))
        {
             ::Segment*sipRes;

            sipRes = new  ::Segment(sipCpp->getSegment(a0));

            return sipConvertFromNewType(sipRes,sipType_Segment,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Chain, sipName_getSegment, doc_Chain_getSegment);

    return NULL;
}


/* Call the instance's destructor. */
extern "C" {static void release_Chain(void *, int);}
static void release_Chain(void *sipCppV, int)
{
    delete reinterpret_cast< ::Chain *>(sipCppV);
}


extern "C" {static void assign_Chain(void *, SIP_SSIZE_T, void *);}
static void assign_Chain(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Chain *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Chain *>(sipSrc);
}


extern "C" {static void *array_Chain(SIP_SSIZE_T);}
static void *array_Chain(SIP_SSIZE_T sipNrElem)
{
    return new  ::Chain[sipNrElem];
}


extern "C" {static void *copy_Chain(const void *, SIP_SSIZE_T);}
static void *copy_Chain(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Chain(reinterpret_cast<const  ::Chain *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Chain(sipSimpleWrapper *);}
static void dealloc_Chain(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Chain(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Chain(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Chain(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Chain *sipCpp = 0;

    {
        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, ""))
        {
            sipCpp = new  ::Chain();

            return sipCpp;
        }
    }

    {
        const  ::Chain* a0;

        static const char *sipKwdList[] = {
            sipName_in,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new  ::Chain(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


static PyMethodDef methods_Chain[] = {
    {SIP_MLNAME_CAST(sipName_addChain), (PyCFunction)meth_Chain_addChain, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Chain_addChain)},
    {SIP_MLNAME_CAST(sipName_addSegment), (PyCFunction)meth_Chain_addSegment, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Chain_addSegment)},
    {SIP_MLNAME_CAST(sipName_getNrOfJoints), meth_Chain_getNrOfJoints, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_getNrOfJoints)},
    {SIP_MLNAME_CAST(sipName_getNrOfSegments), meth_Chain_getNrOfSegments, METH_VARARGS, SIP_MLDOC_CAST(doc_Chain_getNrOfSegments)},
    {SIP_MLNAME_CAST(sipName_getSegment), (PyCFunction)meth_Chain_getSegment, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Chain_getSegment)}
};

PyDoc_STRVAR(doc_Chain, "\1Chain()\n"
"Chain(in_: Chain)");


sipClassTypeDef sipTypeDef_PyKDL_Chain = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Chain,
        {0},
        0
    },
    {
        sipNameNr_Chain,
        {0, 0, 1},
        5, methods_Chain,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Chain,
    -1,
    -1,
    0,
    0,
    init_type_Chain,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Chain,
    assign_Chain,
    array_Chain,
    copy_Chain,
    release_Chain,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 211 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/segment.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 608 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

#line 21 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 612 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 111 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/joint.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 617 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 201 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 623 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 189 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 628 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 281 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 634 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Segment_getFrameToTip, "getFrameToTip(self) -> Frame");

extern "C" {static PyObject *meth_Segment_getFrameToTip(PyObject *, PyObject *);}
static PyObject *meth_Segment_getFrameToTip(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->getFrameToTip());

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getFrameToTip, doc_Segment_getFrameToTip);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_pose, "pose(self, q: float) -> Frame");

extern "C" {static PyObject *meth_Segment_pose(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Segment_pose(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const  ::Segment *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_Segment, &sipCpp, &a0))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->pose(a0));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_pose, doc_Segment_pose);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_twist, "twist(self, q: float, qdot: float) -> Twist");

extern "C" {static PyObject *meth_Segment_twist(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Segment_twist(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        double a1;
        const  ::Segment *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
            sipName_qdot,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bdd", &sipSelf, sipType_Segment, &sipCpp, &a0, &a1))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->twist(a0,a1));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_twist, doc_Segment_twist);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getName, "getName(self) -> object");

extern "C" {static PyObject *meth_Segment_getName(PyObject *, PyObject *);}
static PyObject *meth_Segment_getName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
             ::std::string*sipRes;

            sipRes = new  ::std::string(sipCpp->getName());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getName, doc_Segment_getName);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getJoint, "getJoint(self) -> Joint");

extern "C" {static PyObject *meth_Segment_getJoint(PyObject *, PyObject *);}
static PyObject *meth_Segment_getJoint(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
             ::Joint*sipRes;

            sipRes = new  ::Joint(sipCpp->getJoint());

            return sipConvertFromNewType(sipRes,sipType_Joint,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getJoint, doc_Segment_getJoint);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_getInertia, "getInertia(self) -> RigidBodyInertia");

extern "C" {static PyObject *meth_Segment_getInertia(PyObject *, PyObject *);}
static PyObject *meth_Segment_getInertia(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Segment *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Segment, &sipCpp))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia(sipCpp->getInertia());

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_getInertia, doc_Segment_getInertia);

    return NULL;
}


PyDoc_STRVAR(doc_Segment_setInertia, "setInertia(self, Iin: RigidBodyInertia)");

extern "C" {static PyObject *meth_Segment_setInertia(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Segment_setInertia(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia* a0;
         ::Segment *sipCpp;

        static const char *sipKwdList[] = {
            sipName_Iin,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_Segment, &sipCpp, sipType_RigidBodyInertia, &a0))
        {
            sipCpp->setInertia(*a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Segment, sipName_setInertia, doc_Segment_setInertia);

    return NULL;
}


extern "C" {static PyObject *slot_Segment___repr__(PyObject *);}
static PyObject *slot_Segment___repr__(PyObject *sipSelf)
{
     ::Segment *sipCpp = reinterpret_cast< ::Segment *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Segment));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 222 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    std::stringstream ss;
    ss<<(*sipCpp);
    std::string s(ss.str());
    sipRes=&s;
#line 867 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_Segment(void *, int);}
static void release_Segment(void *sipCppV, int)
{
    delete reinterpret_cast< ::Segment *>(sipCppV);
}


extern "C" {static void assign_Segment(void *, SIP_SSIZE_T, void *);}
static void assign_Segment(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Segment *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Segment *>(sipSrc);
}


extern "C" {static void *array_Segment(SIP_SSIZE_T);}
static void *array_Segment(SIP_SSIZE_T sipNrElem)
{
    return new  ::Segment[sipNrElem];
}


extern "C" {static void *copy_Segment(const void *, SIP_SSIZE_T);}
static void *copy_Segment(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Segment(reinterpret_cast<const  ::Segment *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Segment(sipSimpleWrapper *);}
static void dealloc_Segment(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Segment(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Segment(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Segment(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Segment *sipCpp = 0;

    {
        const  ::std::string* a0;
        int a0State = 0;
        const  ::Joint& a1def = Joint(Joint::None);
        const  ::Joint* a1 = &a1def;
        const  ::Frame& a2def = Frame::Identity();
        const  ::Frame* a2 = &a2def;
        const  ::RigidBodyInertia& a3def = RigidBodyInertia::Zero();
        const  ::RigidBodyInertia* a3 = &a3def;

        static const char *sipKwdList[] = {
            sipName_name,
            sipName_joint,
            sipName_f_tip,
            sipName_I,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1|J9J9J9", sipType_std_string,&a0, &a0State, sipType_Joint, &a1, sipType_Frame, &a2, sipType_RigidBodyInertia, &a3))
        {
            sipCpp = new  ::Segment(*a0,*a1,*a2,*a3);
            sipReleaseType(const_cast< ::std::string *>(a0),sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
        const  ::Joint& a0def = Joint(Joint::None);
        const  ::Joint* a0 = &a0def;
        const  ::Frame& a1def = Frame::Identity();
        const  ::Frame* a1 = &a1def;
        const  ::RigidBodyInertia& a2def = RigidBodyInertia::Zero();
        const  ::RigidBodyInertia* a2 = &a2def;

        static const char *sipKwdList[] = {
            sipName_joint,
            sipName_f_tip,
            sipName_I,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|J9J9J9", sipType_Joint, &a0, sipType_Frame, &a1, sipType_RigidBodyInertia, &a2))
        {
            sipCpp = new  ::Segment(*a0,*a1,*a2);

            return sipCpp;
        }
    }

    {
        const  ::Segment* a0;

        static const char *sipKwdList[] = {
            sipName_in,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Segment, &a0))
        {
            sipCpp = new  ::Segment(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Segment[] = {
    {(void *)slot_Segment___repr__, repr_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Segment[] = {
    {SIP_MLNAME_CAST(sipName_getFrameToTip), meth_Segment_getFrameToTip, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getFrameToTip)},
    {SIP_MLNAME_CAST(sipName_getInertia), meth_Segment_getInertia, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getInertia)},
    {SIP_MLNAME_CAST(sipName_getJoint), meth_Segment_getJoint, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getJoint)},
    {SIP_MLNAME_CAST(sipName_getName), meth_Segment_getName, METH_VARARGS, SIP_MLDOC_CAST(doc_Segment_getName)},
    {SIP_MLNAME_CAST(sipName_pose), (PyCFunction)meth_Segment_pose, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Segment_pose)},
    {SIP_MLNAME_CAST(sipName_setInertia), (PyCFunction)meth_Segment_setInertia, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Segment_setInertia)},
    {SIP_MLNAME_CAST(sipName_twist), (PyCFunction)meth_Segment_twist, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Segment_twist)}
};

PyDoc_STRVAR(doc_Segment, "\1Segment(name: object, joint: Joint = Joint(Joint.None), f_tip: Frame = Frame.Identity(), I: RigidBodyInertia = RigidBodyInertia.Zero())\n"
"Segment(joint: Joint = Joint(Joint.None), f_tip: Frame = Frame.Identity(), I: RigidBodyInertia = RigidBodyInertia.Zero())\n"
"Segment(in_: Segment)");


sipClassTypeDef sipTypeDef_PyKDL_Segment = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Segment,
        {0},
        0
    },
    {
        sipNameNr_Segment,
        {0, 0, 1},
        7, methods_Segment,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Segment,
    -1,
    -1,
    0,
    slots_Segment,
    init_type_Segment,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Segment,
    assign_Segment,
    array_Segment,
    copy_Segment,
    release_Segment,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 189 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rigidbodyinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1066 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

#line 26 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1073 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 153 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rotationalinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1078 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 352 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1084 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 281 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1090 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_RigidBodyInertia_Zero, "Zero() -> RigidBodyInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_Zero(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia( ::RigidBodyInertia::Zero());

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_Zero, doc_RigidBodyInertia_Zero);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_RefPoint, "RefPoint(self, p: Vector) -> RigidBodyInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_RefPoint(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_RefPoint(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Vector* a0;
         ::RigidBodyInertia *sipCpp;

        static const char *sipKwdList[] = {
            sipName_p,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_RigidBodyInertia, &sipCpp, sipType_Vector, &a0))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia(sipCpp->RefPoint(*a0));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_RefPoint, doc_RigidBodyInertia_RefPoint);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getMass, "getMass(self) -> float");

extern "C" {static PyObject *meth_RigidBodyInertia_getMass(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getMass(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->getMass();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getMass, doc_RigidBodyInertia_getMass);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getCOG, "getCOG(self) -> Vector");

extern "C" {static PyObject *meth_RigidBodyInertia_getCOG(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getCOG(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->getCOG());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getCOG, doc_RigidBodyInertia_getCOG);

    return NULL;
}


PyDoc_STRVAR(doc_RigidBodyInertia_getRotationalInertia, "getRotationalInertia(self) -> RotationalInertia");

extern "C" {static PyObject *meth_RigidBodyInertia_getRotationalInertia(PyObject *, PyObject *);}
static PyObject *meth_RigidBodyInertia_getRotationalInertia(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_RigidBodyInertia, &sipCpp))
        {
             ::RotationalInertia*sipRes;

            sipRes = new  ::RotationalInertia(sipCpp->getRotationalInertia());

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RigidBodyInertia, sipName_getRotationalInertia, doc_RigidBodyInertia_getRotationalInertia);

    return NULL;
}


extern "C" {static PyObject *slot_RigidBodyInertia___mul__(PyObject *,PyObject *);}
static PyObject *slot_RigidBodyInertia___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const  ::RigidBodyInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_RigidBodyInertia, &a1))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    {
        const  ::RigidBodyInertia* a0;
        const  ::Twist* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RigidBodyInertia, &a0, sipType_Twist, &a1))
        {
             ::Wrench*sipRes;

            sipRes = new  ::Wrench((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Wrench,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_RigidBodyInertia___add__(PyObject *,PyObject *);}
static PyObject *slot_RigidBodyInertia___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RigidBodyInertia* a0;
        const  ::RigidBodyInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RigidBodyInertia, &a0, sipType_RigidBodyInertia, &a1))
        {
             ::RigidBodyInertia*sipRes;

            sipRes = new  ::RigidBodyInertia((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_RigidBodyInertia,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, add_slot, NULL, sipArg0, sipArg1);
}


/* Call the instance's destructor. */
extern "C" {static void release_RigidBodyInertia(void *, int);}
static void release_RigidBodyInertia(void *sipCppV, int)
{
    delete reinterpret_cast< ::RigidBodyInertia *>(sipCppV);
}


extern "C" {static void assign_RigidBodyInertia(void *, SIP_SSIZE_T, void *);}
static void assign_RigidBodyInertia(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::RigidBodyInertia *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::RigidBodyInertia *>(sipSrc);
}


extern "C" {static void *array_RigidBodyInertia(SIP_SSIZE_T);}
static void *array_RigidBodyInertia(SIP_SSIZE_T sipNrElem)
{
    return new  ::RigidBodyInertia[sipNrElem];
}


extern "C" {static void *copy_RigidBodyInertia(const void *, SIP_SSIZE_T);}
static void *copy_RigidBodyInertia(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::RigidBodyInertia(reinterpret_cast<const  ::RigidBodyInertia *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_RigidBodyInertia(sipSimpleWrapper *);}
static void dealloc_RigidBodyInertia(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_RigidBodyInertia(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_RigidBodyInertia(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_RigidBodyInertia(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::RigidBodyInertia *sipCpp = 0;

    {
        double a0 = 0;
        const  ::Vector& a1def = Vector::Zero();
        const  ::Vector* a1 = &a1def;
        const  ::RotationalInertia& a2def = RotationalInertia::Zero();
        const  ::RotationalInertia* a2 = &a2def;

        static const char *sipKwdList[] = {
            sipName_m,
            sipName_oc,
            sipName_Ic,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|dJ9J9", &a0, sipType_Vector, &a1, sipType_RotationalInertia, &a2))
        {
            sipCpp = new  ::RigidBodyInertia(a0,*a1,*a2);

            return sipCpp;
        }
    }

    {
        const  ::RigidBodyInertia* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_RigidBodyInertia, &a0))
        {
            sipCpp = new  ::RigidBodyInertia(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_RigidBodyInertia[] = {
    {(void *)slot_RigidBodyInertia___mul__, mul_slot},
    {(void *)slot_RigidBodyInertia___add__, add_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_RigidBodyInertia[] = {
    {SIP_MLNAME_CAST(sipName_RefPoint), (PyCFunction)meth_RigidBodyInertia_RefPoint, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_RigidBodyInertia_RefPoint)},
    {SIP_MLNAME_CAST(sipName_Zero), meth_RigidBodyInertia_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_Zero)},
    {SIP_MLNAME_CAST(sipName_getCOG), meth_RigidBodyInertia_getCOG, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getCOG)},
    {SIP_MLNAME_CAST(sipName_getMass), meth_RigidBodyInertia_getMass, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getMass)},
    {SIP_MLNAME_CAST(sipName_getRotationalInertia), meth_RigidBodyInertia_getRotationalInertia, METH_VARARGS, SIP_MLDOC_CAST(doc_RigidBodyInertia_getRotationalInertia)}
};

PyDoc_STRVAR(doc_RigidBodyInertia, "\1RigidBodyInertia(m: float = 0, oc: Vector = Vector.Zero(), Ic: RotationalInertia = RotationalInertia.Zero())\n"
"RigidBodyInertia(RigidBodyInertia)");


sipClassTypeDef sipTypeDef_PyKDL_RigidBodyInertia = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_RigidBodyInertia,
        {0},
        0
    },
    {
        sipNameNr_RigidBodyInertia,
        {0, 0, 1},
        5, methods_RigidBodyInertia,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_RigidBodyInertia,
    -1,
    -1,
    0,
    slots_RigidBodyInertia,
    init_type_RigidBodyInertia,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_RigidBodyInertia,
    assign_RigidBodyInertia,
    array_RigidBodyInertia,
    copy_RigidBodyInertia,
    release_RigidBodyInertia,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 153 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/rotationalinertia.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1461 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

#line 26 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1468 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_RotationalInertia_Zero, "Zero() -> RotationalInertia");

extern "C" {static PyObject *meth_RotationalInertia_Zero(PyObject *, PyObject *);}
static PyObject *meth_RotationalInertia_Zero(PyObject *, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        if (sipParseArgs(&sipParseErr, sipArgs, ""))
        {
             ::RotationalInertia*sipRes;

            sipRes = new  ::RotationalInertia( ::RotationalInertia::Zero());

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationalInertia, sipName_Zero, doc_RotationalInertia_Zero);

    return NULL;
}


extern "C" {static PyObject *slot_RotationalInertia___mul__(PyObject *,PyObject *);}
static PyObject *slot_RotationalInertia___mul__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
         ::RotationalInertia* a0;
         ::Vector* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RotationalInertia, &a0, sipType_Vector, &a1))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector((*a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    {
        double a0;
        const  ::RotationalInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "dJ9", &a0, sipType_RotationalInertia, &a1))
        {
             ::RotationalInertia*sipRes;

            sipRes = new  ::RotationalInertia((a0 * *a1));

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, mul_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static PyObject *slot_RotationalInertia___add__(PyObject *,PyObject *);}
static PyObject *slot_RotationalInertia___add__(PyObject *sipArg0,PyObject *sipArg1)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::RotationalInertia* a0;
        const  ::RotationalInertia* a1;

        if (sipParsePair(&sipParseErr, sipArg0, sipArg1, "J9J9", sipType_RotationalInertia, &a0, sipType_RotationalInertia, &a1))
        {
             ::RotationalInertia*sipRes;

            sipRes = new  ::RotationalInertia((*a0 + *a1));

            return sipConvertFromNewType(sipRes,sipType_RotationalInertia,NULL);
        }
    }

    Py_XDECREF(sipParseErr);

    if (sipParseErr == Py_None)
        return NULL;

    return sipPySlotExtend(&sipModuleAPI_PyKDL, add_slot, NULL, sipArg0, sipArg1);
}


extern "C" {static int slot_RotationalInertia___setitem__(PyObject *,PyObject *);}
static int slot_RotationalInertia___setitem__(PyObject *sipSelf,PyObject *sipArgs)
{
     ::RotationalInertia *sipCpp = reinterpret_cast< ::RotationalInertia *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_RotationalInertia));

    if (!sipCpp)
        return -1;

    PyObject *sipParseErr = NULL;

    {
        int a0;
        double a1;

        if (sipParseArgs(&sipParseErr, sipArgs, "id", &a0, &a1))
        {
#line 173 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    if (a0 < 0 || a0 >= 9) {
        PyErr_SetString(PyExc_IndexError, "RotationalInertia index out of range");
        return 0;
    }
    (*sipCpp).data[a0]=a1;
#line 1589 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

            return 0;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationalInertia, sipName___setitem__, NULL);

    return -1;
}


extern "C" {static PyObject *slot_RotationalInertia___getitem__(PyObject *,PyObject *);}
static PyObject *slot_RotationalInertia___getitem__(PyObject *sipSelf,PyObject *sipArg)
{
     ::RotationalInertia *sipCpp = reinterpret_cast< ::RotationalInertia *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_RotationalInertia));

    if (!sipCpp)
        return 0;

    PyObject *sipParseErr = NULL;

    {
        int a0;

        if (sipParseArgs(&sipParseErr, sipArg, "1i", &a0))
        {
            double sipRes = 0;

#line 164 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    if (a0 < 0 || a0 >= 9) {
        PyErr_SetString(PyExc_IndexError, "RotationalInertia index out of range");
        return 0;
    }
    sipRes=(*sipCpp).data[a0];
#line 1625 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_RotationalInertia, sipName___getitem__, NULL);

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_RotationalInertia(void *, int);}
static void release_RotationalInertia(void *sipCppV, int)
{
    delete reinterpret_cast< ::RotationalInertia *>(sipCppV);
}


extern "C" {static void assign_RotationalInertia(void *, SIP_SSIZE_T, void *);}
static void assign_RotationalInertia(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::RotationalInertia *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::RotationalInertia *>(sipSrc);
}


extern "C" {static void *array_RotationalInertia(SIP_SSIZE_T);}
static void *array_RotationalInertia(SIP_SSIZE_T sipNrElem)
{
    return new  ::RotationalInertia[sipNrElem];
}


extern "C" {static void *copy_RotationalInertia(const void *, SIP_SSIZE_T);}
static void *copy_RotationalInertia(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::RotationalInertia(reinterpret_cast<const  ::RotationalInertia *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_RotationalInertia(sipSimpleWrapper *);}
static void dealloc_RotationalInertia(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_RotationalInertia(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_RotationalInertia(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_RotationalInertia(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::RotationalInertia *sipCpp = 0;

    {
        double a0 = 0;
        double a1 = 0;
        double a2 = 0;
        double a3 = 0;
        double a4 = 0;
        double a5 = 0;

        static const char *sipKwdList[] = {
            sipName_Ixx,
            sipName_Iyy,
            sipName_Izz,
            sipName_Ixy,
            sipName_Ixz,
            sipName_Iyz,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|dddddd", &a0, &a1, &a2, &a3, &a4, &a5))
        {
            sipCpp = new  ::RotationalInertia(a0,a1,a2,a3,a4,a5);

            return sipCpp;
        }
    }

    {
        const  ::RotationalInertia* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_RotationalInertia, &a0))
        {
            sipCpp = new  ::RotationalInertia(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_RotationalInertia[] = {
    {(void *)slot_RotationalInertia___mul__, mul_slot},
    {(void *)slot_RotationalInertia___add__, add_slot},
    {(void *)slot_RotationalInertia___setitem__, setitem_slot},
    {(void *)slot_RotationalInertia___getitem__, getitem_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_RotationalInertia[] = {
    {SIP_MLNAME_CAST(sipName_Zero), meth_RotationalInertia_Zero, METH_VARARGS, SIP_MLDOC_CAST(doc_RotationalInertia_Zero)}
};

PyDoc_STRVAR(doc_RotationalInertia, "\1RotationalInertia(Ixx: float = 0, Iyy: float = 0, Izz: float = 0, Ixy: float = 0, Ixz: float = 0, Iyz: float = 0)\n"
"RotationalInertia(RotationalInertia)");


sipClassTypeDef sipTypeDef_PyKDL_RotationalInertia = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_RotationalInertia,
        {0},
        0
    },
    {
        sipNameNr_RotationalInertia,
        {0, 0, 1},
        1, methods_RotationalInertia,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_RotationalInertia,
    -1,
    -1,
    0,
    slots_RotationalInertia,
    init_type_RotationalInertia,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_RotationalInertia,
    assign_RotationalInertia,
    array_RotationalInertia,
    copy_RotationalInertia,
    release_RotationalInertia,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 111 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/joint.hpp>
#include <kdl/kinfam_io.hpp>
using namespace KDL;
#line 1795 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

#line 21 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/std_string.sip"
#include <string>
#line 1799 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 26 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1805 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 281 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1811 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"
#line 201 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1817 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"


PyDoc_STRVAR(doc_Joint_pose, "pose(self, q: float) -> Frame");

extern "C" {static PyObject *meth_Joint_pose(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Joint_pose(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const  ::Joint *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_Joint, &sipCpp, &a0))
        {
             ::Frame*sipRes;

            sipRes = new  ::Frame(sipCpp->pose(a0));

            return sipConvertFromNewType(sipRes,sipType_Frame,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_pose, doc_Joint_pose);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_twist, "twist(self, qdot: float) -> Twist");

extern "C" {static PyObject *meth_Joint_twist(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_Joint_twist(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
        const  ::Joint *sipCpp;

        static const char *sipKwdList[] = {
            sipName_qdot,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_Joint, &sipCpp, &a0))
        {
             ::Twist*sipRes;

            sipRes = new  ::Twist(sipCpp->twist(a0));

            return sipConvertFromNewType(sipRes,sipType_Twist,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_twist, doc_Joint_twist);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_JointAxis, "JointAxis(self) -> Vector");

extern "C" {static PyObject *meth_Joint_JointAxis(PyObject *, PyObject *);}
static PyObject *meth_Joint_JointAxis(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->JointAxis());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_JointAxis, doc_Joint_JointAxis);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_JointOrigin, "JointOrigin(self) -> Vector");

extern "C" {static PyObject *meth_Joint_JointOrigin(PyObject *, PyObject *);}
static PyObject *meth_Joint_JointOrigin(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
             ::Vector*sipRes;

            sipRes = new  ::Vector(sipCpp->JointOrigin());

            return sipConvertFromNewType(sipRes,sipType_Vector,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_JointOrigin, doc_Joint_JointOrigin);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_getName, "getName(self) -> object");

extern "C" {static PyObject *meth_Joint_getName(PyObject *, PyObject *);}
static PyObject *meth_Joint_getName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
             ::std::string*sipRes;

            sipRes = new  ::std::string(sipCpp->getName());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_getName, doc_Joint_getName);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_getInertia, "getInertia(self) -> float");

extern "C" {static PyObject *meth_Joint_getInertia(PyObject *, PyObject *);}
static PyObject *meth_Joint_getInertia(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->getInertia();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_getInertia, doc_Joint_getInertia);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_getDamping, "getDamping(self) -> float");

extern "C" {static PyObject *meth_Joint_getDamping(PyObject *, PyObject *);}
static PyObject *meth_Joint_getDamping(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->getDamping();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_getDamping, doc_Joint_getDamping);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_getStiffness, "getStiffness(self) -> float");

extern "C" {static PyObject *meth_Joint_getStiffness(PyObject *, PyObject *);}
static PyObject *meth_Joint_getStiffness(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->getStiffness();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_getStiffness, doc_Joint_getStiffness);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_getType, "getType(self) -> Joint.JointType");

extern "C" {static PyObject *meth_Joint_getType(PyObject *, PyObject *);}
static PyObject *meth_Joint_getType(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
             ::Joint::JointType sipRes;

            sipRes = sipCpp->getType();

            return sipConvertFromEnum(static_cast<int>(sipRes), sipType_Joint_JointType);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_getType, doc_Joint_getType);

    return NULL;
}


PyDoc_STRVAR(doc_Joint_getTypeName, "getTypeName(self) -> object");

extern "C" {static PyObject *meth_Joint_getTypeName(PyObject *, PyObject *);}
static PyObject *meth_Joint_getTypeName(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::Joint *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_Joint, &sipCpp))
        {
             ::std::string*sipRes;

            sipRes = new  ::std::string(sipCpp->getTypeName());

            return sipConvertFromNewType(sipRes,sipType_std_string,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_Joint, sipName_getTypeName, doc_Joint_getTypeName);

    return NULL;
}


extern "C" {static PyObject *slot_Joint___repr__(PyObject *);}
static PyObject *slot_Joint___repr__(PyObject *sipSelf)
{
     ::Joint *sipCpp = reinterpret_cast< ::Joint *>(sipGetCppPtr((sipSimpleWrapper *)sipSelf,sipType_Joint));

    if (!sipCpp)
        return 0;


    {
        {
            const  ::std::string*sipRes = 0;

#line 143 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
        std::ostringstream oss;
        oss<<(*sipCpp);
        std::string s(oss.str());
        sipRes=&s;
#line 2128 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart5.cpp"

            return sipConvertFromType(const_cast< ::std::string *>(sipRes),sipType_std_string,NULL);
        }
    }

    return 0;
}


/* Call the instance's destructor. */
extern "C" {static void release_Joint(void *, int);}
static void release_Joint(void *sipCppV, int)
{
    delete reinterpret_cast< ::Joint *>(sipCppV);
}


extern "C" {static void assign_Joint(void *, SIP_SSIZE_T, void *);}
static void assign_Joint(void *sipDst, SIP_SSIZE_T sipDstIdx, void *sipSrc)
{
    reinterpret_cast< ::Joint *>(sipDst)[sipDstIdx] = *reinterpret_cast< ::Joint *>(sipSrc);
}


extern "C" {static void *array_Joint(SIP_SSIZE_T);}
static void *array_Joint(SIP_SSIZE_T sipNrElem)
{
    return new  ::Joint[sipNrElem];
}


extern "C" {static void *copy_Joint(const void *, SIP_SSIZE_T);}
static void *copy_Joint(const void *sipSrc, SIP_SSIZE_T sipSrcIdx)
{
    return new  ::Joint(reinterpret_cast<const  ::Joint *>(sipSrc)[sipSrcIdx]);
}


extern "C" {static void dealloc_Joint(sipSimpleWrapper *);}
static void dealloc_Joint(sipSimpleWrapper *sipSelf)
{
    if (sipIsOwnedByPython(sipSelf))
    {
        release_Joint(sipGetAddress(sipSelf), 0);
    }
}


extern "C" {static void *init_type_Joint(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_Joint(sipSimpleWrapper *, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
     ::Joint *sipCpp = 0;

    {
         ::std::string* a0;
        int a0State = 0;
         ::Joint::JointType a1 =  ::Joint::None;
        double a2 = 1;
        double a3 = 0;
        double a4 = 0;
        double a5 = 0;
        double a6 = 0;

        static const char *sipKwdList[] = {
            sipName_name,
            sipName_type,
            sipName_scale,
            sipName_offset,
            sipName_inertia,
            sipName_damping,
            sipName_stiffness,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1|Eddddd", sipType_std_string,&a0, &a0State, sipType_Joint_JointType, &a1, &a2, &a3, &a4, &a5, &a6))
        {
            sipCpp = new  ::Joint(*a0,a1,a2,a3,a4,a5,a6);
            sipReleaseType(a0,sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
         ::Joint::JointType a0 =  ::Joint::None;
        double a1 = 1;
        double a2 = 0;
        double a3 = 0;
        double a4 = 0;
        double a5 = 0;

        static const char *sipKwdList[] = {
            sipName_type,
            sipName_scale,
            sipName_offset,
            sipName_inertia,
            sipName_damping,
            sipName_stiffness,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "|Eddddd", sipType_Joint_JointType, &a0, &a1, &a2, &a3, &a4, &a5))
        {
            sipCpp = new  ::Joint(a0,a1,a2,a3,a4,a5);

            return sipCpp;
        }
    }

    {
         ::std::string* a0;
        int a0State = 0;
         ::Vector* a1;
         ::Vector* a2;
         ::Joint::JointType a3;
        double a4 = 1;
        double a5 = 0;
        double a6 = 0;
        double a7 = 0;
        double a8 = 0;

        static const char *sipKwdList[] = {
            sipName_name,
            sipName_origin,
            sipName_axis,
            sipName_type,
            sipName_scale,
            sipName_offset,
            sipName_inertia,
            sipName_damping,
            sipName_stiffness,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J1J9J9E|ddddd", sipType_std_string,&a0, &a0State, sipType_Vector, &a1, sipType_Vector, &a2, sipType_Joint_JointType, &a3, &a4, &a5, &a6, &a7, &a8))
        {
            sipCpp = new  ::Joint(*a0,*a1,*a2,a3,a4,a5,a6,a7,a8);
            sipReleaseType(a0,sipType_std_string,a0State);

            return sipCpp;
        }
    }

    {
         ::Vector* a0;
         ::Vector* a1;
         ::Joint::JointType a2;
        double a3 = 1;
        double a4 = 0;
        double a5 = 0;
        double a6 = 0;
        double a7 = 0;

        static const char *sipKwdList[] = {
            sipName_origin,
            sipName_axis,
            sipName_type,
            sipName_scale,
            sipName_offset,
            sipName_inertia,
            sipName_damping,
            sipName_stiffness,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9J9E|ddddd", sipType_Vector, &a0, sipType_Vector, &a1, sipType_Joint_JointType, &a2, &a3, &a4, &a5, &a6, &a7))
        {
            sipCpp = new  ::Joint(*a0,*a1,a2,a3,a4,a5,a6,a7);

            return sipCpp;
        }
    }

    {
        const  ::Joint* a0;

        static const char *sipKwdList[] = {
            sipName_in,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Joint, &a0))
        {
            sipCpp = new  ::Joint(*a0);

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's Python slots. */
static sipPySlotDef slots_Joint[] = {
    {(void *)slot_Joint___repr__, repr_slot},
    {0, (sipPySlotType)0}
};


static PyMethodDef methods_Joint[] = {
    {SIP_MLNAME_CAST(sipName_JointAxis), meth_Joint_JointAxis, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_JointAxis)},
    {SIP_MLNAME_CAST(sipName_JointOrigin), meth_Joint_JointOrigin, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_JointOrigin)},
    {SIP_MLNAME_CAST(sipName_getDamping), meth_Joint_getDamping, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_getDamping)},
    {SIP_MLNAME_CAST(sipName_getInertia), meth_Joint_getInertia, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_getInertia)},
    {SIP_MLNAME_CAST(sipName_getName), meth_Joint_getName, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_getName)},
    {SIP_MLNAME_CAST(sipName_getStiffness), meth_Joint_getStiffness, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_getStiffness)},
    {SIP_MLNAME_CAST(sipName_getType), meth_Joint_getType, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_getType)},
    {SIP_MLNAME_CAST(sipName_getTypeName), meth_Joint_getTypeName, METH_VARARGS, SIP_MLDOC_CAST(doc_Joint_getTypeName)},
    {SIP_MLNAME_CAST(sipName_pose), (PyCFunction)meth_Joint_pose, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Joint_pose)},
    {SIP_MLNAME_CAST(sipName_twist), (PyCFunction)meth_Joint_twist, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_Joint_twist)}
};

static sipEnumMemberDef enummembers_Joint[] = {
    {sipName_None, static_cast<int>( ::Joint::None), 26},
    {sipName_RotAxis, static_cast<int>( ::Joint::RotAxis), 26},
    {sipName_RotX, static_cast<int>( ::Joint::RotX), 26},
    {sipName_RotY, static_cast<int>( ::Joint::RotY), 26},
    {sipName_RotZ, static_cast<int>( ::Joint::RotZ), 26},
    {sipName_TransAxis, static_cast<int>( ::Joint::TransAxis), 26},
    {sipName_TransX, static_cast<int>( ::Joint::TransX), 26},
    {sipName_TransY, static_cast<int>( ::Joint::TransY), 26},
    {sipName_TransZ, static_cast<int>( ::Joint::TransZ), 26},
};

PyDoc_STRVAR(doc_Joint, "\1Joint(name: object, type: Joint.JointType = Joint.None, scale: float = 1, offset: float = 0, inertia: float = 0, damping: float = 0, stiffness: float = 0)\n"
"Joint(type: Joint.JointType = Joint.None, scale: float = 1, offset: float = 0, inertia: float = 0, damping: float = 0, stiffness: float = 0)\n"
"Joint(name: object, origin: Vector, axis: Vector, type: Joint.JointType, scale: float = 1, offset: float = 0, inertia: float = 0, damping: float = 0, stiffness: float = 0)\n"
"Joint(origin: Vector, axis: Vector, type: Joint.JointType, scale: float = 1, offset: float = 0, inertia: float = 0, damping: float = 0, stiffness: float = 0)\n"
"Joint(in_: Joint)");


sipClassTypeDef sipTypeDef_PyKDL_Joint = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_Joint,
        {0},
        0
    },
    {
        sipNameNr_Joint,
        {0, 0, 1},
        10, methods_Joint,
        9, enummembers_Joint,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_Joint,
    -1,
    -1,
    0,
    slots_Joint,
    init_type_Joint,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_Joint,
    assign_Joint,
    array_Joint,
    copy_Joint,
    release_Joint,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};

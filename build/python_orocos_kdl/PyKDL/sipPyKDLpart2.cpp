/*
 * Module code.
 *
 * Generated by SIP 4.19.7
 */

#include "sipAPIPyKDL.h"

#line 675 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainjnttojacsolver.hpp>
using namespace KDL;
#line 13 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

#line 241 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 18 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 280 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 22 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 361 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 26 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"


class sipChainJntToJacSolver : public  ::ChainJntToJacSolver
{
public:
    sipChainJntToJacSolver(const  ::Chain&);
    sipChainJntToJacSolver(const  ::ChainJntToJacSolver&);
    virtual ~sipChainJntToJacSolver();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainJntToJacSolver(const sipChainJntToJacSolver &);
    sipChainJntToJacSolver &operator = (const sipChainJntToJacSolver &);

    char sipPyMethods[1];
};

sipChainJntToJacSolver::sipChainJntToJacSolver(const  ::Chain& a0):  ::ChainJntToJacSolver(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainJntToJacSolver::sipChainJntToJacSolver(const  ::ChainJntToJacSolver& a0):  ::ChainJntToJacSolver(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainJntToJacSolver::~sipChainJntToJacSolver()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainJntToJacSolver::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainJntToJacSolver::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}


PyDoc_STRVAR(doc_ChainJntToJacSolver_JntToJac, "JntToJac(self, q_in: JntArray, jac: Jacobian, seg_nr: int = -1) -> int");

extern "C" {static PyObject *meth_ChainJntToJacSolver_JntToJac(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainJntToJacSolver_JntToJac(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::JntArray* a0;
         ::Jacobian* a1;
        int a2 = -1;
         ::ChainJntToJacSolver *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_jac,
            sipName_seg_nr,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9|i", &sipSelf, sipType_ChainJntToJacSolver, &sipCpp, sipType_JntArray, &a0, sipType_Jacobian, &a1, &a2))
        {
            int sipRes;

            sipRes = sipCpp->JntToJac(*a0,*a1,a2);

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainJntToJacSolver, sipName_JntToJac, doc_ChainJntToJacSolver_JntToJac);

    return NULL;
}


PyDoc_STRVAR(doc_ChainJntToJacSolver_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainJntToJacSolver_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainJntToJacSolver_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainJntToJacSolver *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainJntToJacSolver, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainJntToJacSolver::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainJntToJacSolver, sipName_updateInternalDataStructures, doc_ChainJntToJacSolver_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainJntToJacSolver(void *, const sipTypeDef *);}
static void *cast_ChainJntToJacSolver(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainJntToJacSolver *sipCpp = reinterpret_cast< ::ChainJntToJacSolver *>(sipCppV);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainJntToJacSolver(void *, int);}
static void release_ChainJntToJacSolver(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainJntToJacSolver *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainJntToJacSolver *>(sipCppV);
}


extern "C" {static void dealloc_ChainJntToJacSolver(sipSimpleWrapper *);}
static void dealloc_ChainJntToJacSolver(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainJntToJacSolver *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainJntToJacSolver(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainJntToJacSolver(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainJntToJacSolver(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainJntToJacSolver *sipCpp = 0;

    {
        const  ::Chain* a0;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new sipChainJntToJacSolver(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainJntToJacSolver* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainJntToJacSolver, &a0))
        {
            sipCpp = new sipChainJntToJacSolver(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainJntToJacSolver[] = {{32, 255, 1}};


static PyMethodDef methods_ChainJntToJacSolver[] = {
    {SIP_MLNAME_CAST(sipName_JntToJac), (PyCFunction)meth_ChainJntToJacSolver_JntToJac, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainJntToJacSolver_JntToJac)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainJntToJacSolver_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainJntToJacSolver_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainJntToJacSolver, "\1ChainJntToJacSolver(chain: Chain)\n"
"ChainJntToJacSolver(ChainJntToJacSolver)");


sipClassTypeDef sipTypeDef_PyKDL_ChainJntToJacSolver = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainJntToJacSolver,
        {0},
        0
    },
    {
        sipNameNr_ChainJntToJacSolver,
        {0, 0, 1},
        2, methods_ChainJntToJacSolver,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainJntToJacSolver,
    -1,
    -1,
    supers_ChainJntToJacSolver,
    0,
    init_type_ChainJntToJacSolver,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainJntToJacSolver,
    0,
    0,
    0,
    release_ChainJntToJacSolver,
    cast_ChainJntToJacSolver,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 662 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_pinv_givens.hpp>
using namespace KDL;
#line 295 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

#line 241 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 300 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 280 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 304 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 281 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 310 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverVel_pinv_givens : public  ::ChainIkSolverVel_pinv_givens
{
public:
    sipChainIkSolverVel_pinv_givens(const  ::Chain&);
    sipChainIkSolverVel_pinv_givens(const  ::ChainIkSolverVel_pinv_givens&);
    virtual ~sipChainIkSolverVel_pinv_givens();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_pinv_givens(const sipChainIkSolverVel_pinv_givens &);
    sipChainIkSolverVel_pinv_givens &operator = (const sipChainIkSolverVel_pinv_givens &);

    char sipPyMethods[2];
};

sipChainIkSolverVel_pinv_givens::sipChainIkSolverVel_pinv_givens(const  ::Chain& a0):  ::ChainIkSolverVel_pinv_givens(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv_givens::sipChainIkSolverVel_pinv_givens(const  ::ChainIkSolverVel_pinv_givens& a0):  ::ChainIkSolverVel_pinv_givens(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv_givens::~sipChainIkSolverVel_pinv_givens()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverVel_pinv_givens::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverVel_pinv_givens::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_pinv_givens::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_givens::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_givens_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_givens_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_givens_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel_pinv_givens *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_pinv_givens, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_givens::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_givens, sipName_CartToJnt, doc_ChainIkSolverVel_pinv_givens_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_givens_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_givens_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_givens_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverVel_pinv_givens *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_givens, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_givens::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_givens, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_pinv_givens_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_pinv_givens(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_pinv_givens(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel_pinv_givens *sipCpp = reinterpret_cast< ::ChainIkSolverVel_pinv_givens *>(sipCppV);

    if (targetType == sipType_ChainIkSolverVel)
        return static_cast< ::ChainIkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_pinv_givens(void *, int);}
static void release_ChainIkSolverVel_pinv_givens(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_pinv_givens *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel_pinv_givens *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_pinv_givens(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_pinv_givens(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_pinv_givens *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel_pinv_givens(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_pinv_givens(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_pinv_givens(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_pinv_givens *sipCpp = 0;

    {
        const  ::Chain* a0;

        static const char *sipKwdList[] = {
            sipName_chain,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9", sipType_Chain, &a0))
        {
            sipCpp = new sipChainIkSolverVel_pinv_givens(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel_pinv_givens* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_pinv_givens, &a0))
        {
            sipCpp = new sipChainIkSolverVel_pinv_givens(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_pinv_givens[] = {{12, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_pinv_givens[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_pinv_givens_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_givens_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_pinv_givens_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_givens_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_givens, "\1ChainIkSolverVel_pinv_givens(chain: Chain)\n"
"ChainIkSolverVel_pinv_givens(ChainIkSolverVel_pinv_givens)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_pinv_givens = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_pinv_givens,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverVel_pinv_givens,
        {0, 0, 1},
        2, methods_ChainIkSolverVel_pinv_givens,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_pinv_givens,
    -1,
    -1,
    supers_ChainIkSolverVel_pinv_givens,
    0,
    init_type_ChainIkSolverVel_pinv_givens,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_pinv_givens,
    0,
    0,
    0,
    release_ChainIkSolverVel_pinv_givens,
    cast_ChainIkSolverVel_pinv_givens,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 637 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_pinv_nso.hpp>
using namespace KDL;
#line 599 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

#line 241 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 604 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 280 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 608 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 281 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 614 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverVel_pinv_nso : public  ::ChainIkSolverVel_pinv_nso
{
public:
    sipChainIkSolverVel_pinv_nso(const  ::Chain&,double,int,double);
    sipChainIkSolverVel_pinv_nso(const  ::ChainIkSolverVel_pinv_nso&);
    virtual ~sipChainIkSolverVel_pinv_nso();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    int setAlpha(const double);
    int setOptPos(const  ::JntArray&);
    int setWeights(const  ::JntArray&);
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_pinv_nso(const sipChainIkSolverVel_pinv_nso &);
    sipChainIkSolverVel_pinv_nso &operator = (const sipChainIkSolverVel_pinv_nso &);

    char sipPyMethods[5];
};

sipChainIkSolverVel_pinv_nso::sipChainIkSolverVel_pinv_nso(const  ::Chain& a0,double a1,int a2,double a3):  ::ChainIkSolverVel_pinv_nso(a0,a1,a2,a3), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv_nso::sipChainIkSolverVel_pinv_nso(const  ::ChainIkSolverVel_pinv_nso& a0):  ::ChainIkSolverVel_pinv_nso(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv_nso::~sipChainIkSolverVel_pinv_nso()
{
    sipInstanceDestroyed(sipPySelf);
}

int sipChainIkSolverVel_pinv_nso::setAlpha(const double a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_setAlpha);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_nso::setAlpha(a0);

    extern int sipVH_PyKDL_9(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const double);

    return sipVH_PyKDL_9(sipGILState, 0, sipPySelf, sipMeth, a0);
}

int sipChainIkSolverVel_pinv_nso::setOptPos(const  ::JntArray& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_setOptPos);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_nso::setOptPos(a0);

    extern int sipVH_PyKDL_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&);

    return sipVH_PyKDL_8(sipGILState, 0, sipPySelf, sipMeth, a0);
}

int sipChainIkSolverVel_pinv_nso::setWeights(const  ::JntArray& a0)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[2],sipPySelf,NULL,sipName_setWeights);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_nso::setWeights(a0);

    extern int sipVH_PyKDL_8(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&);

    return sipVH_PyKDL_8(sipGILState, 0, sipPySelf, sipMeth, a0);
}

void sipChainIkSolverVel_pinv_nso::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[3],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverVel_pinv_nso::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_pinv_nso::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[4],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv_nso::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_CartToJnt, doc_ChainIkSolverVel_pinv_nso_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_pinv_nso_updateInternalDataStructures);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_setWeights, "setWeights(self, weights: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_setWeights(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_setWeights(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_weights,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, sipType_JntArray, &a0))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::setWeights(*a0) : sipCpp->setWeights(*a0));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_setWeights, doc_ChainIkSolverVel_pinv_nso_setWeights);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_setOptPos, "setOptPos(self, opt_pos: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_setOptPos(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_setOptPos(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_opt_pos,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, sipType_JntArray, &a0))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::setOptPos(*a0) : sipCpp->setOptPos(*a0));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_setOptPos, doc_ChainIkSolverVel_pinv_nso_setOptPos);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_setAlpha, "setAlpha(self, alpha: float) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_setAlpha(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_setAlpha(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        double a0;
         ::ChainIkSolverVel_pinv_nso *sipCpp;

        static const char *sipKwdList[] = {
            sipName_alpha,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp, &a0))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv_nso::setAlpha(a0) : sipCpp->setAlpha(a0));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_setAlpha, doc_ChainIkSolverVel_pinv_nso_setAlpha);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_getWeights, "getWeights(self) -> JntArray");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_getWeights(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_getWeights(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
             ::JntArray*sipRes;

            sipRes = new  ::JntArray(sipCpp->getWeights());

            return sipConvertFromNewType(sipRes,sipType_JntArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_getWeights, doc_ChainIkSolverVel_pinv_nso_getWeights);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_getOptPos, "getOptPos(self) -> JntArray");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_getOptPos(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_getOptPos(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
             ::JntArray*sipRes;

            sipRes = new  ::JntArray(sipCpp->getOptPos());

            return sipConvertFromNewType(sipRes,sipType_JntArray,NULL);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_getOptPos, doc_ChainIkSolverVel_pinv_nso_getOptPos);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso_getAlpha, "getAlpha(self) -> float");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_nso_getAlpha(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_nso_getAlpha(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        const  ::ChainIkSolverVel_pinv_nso *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv_nso, &sipCpp))
        {
            double sipRes;

            sipRes = sipCpp->getAlpha();

            return PyFloat_FromDouble(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv_nso, sipName_getAlpha, doc_ChainIkSolverVel_pinv_nso_getAlpha);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_pinv_nso(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_pinv_nso(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel_pinv_nso *sipCpp = reinterpret_cast< ::ChainIkSolverVel_pinv_nso *>(sipCppV);

    if (targetType == sipType_ChainIkSolverVel)
        return static_cast< ::ChainIkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_pinv_nso(void *, int);}
static void release_ChainIkSolverVel_pinv_nso(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_pinv_nso *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel_pinv_nso *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_pinv_nso *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel_pinv_nso(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_pinv_nso(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_pinv_nso *sipCpp = 0;

    {
        const  ::Chain* a0;
        double a1 = 1e-05;
        int a2 = 150;
        double a3 = 0.25;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName_maxiter,
            sipName_alpha,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|did", sipType_Chain, &a0, &a1, &a2, &a3))
        {
            sipCpp = new sipChainIkSolverVel_pinv_nso(*a0,a1,a2,a3);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel_pinv_nso* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_pinv_nso, &a0))
        {
            sipCpp = new sipChainIkSolverVel_pinv_nso(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_pinv_nso[] = {{12, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_pinv_nso[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_getAlpha), meth_ChainIkSolverVel_pinv_nso_getAlpha, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_getAlpha)},
    {SIP_MLNAME_CAST(sipName_getOptPos), meth_ChainIkSolverVel_pinv_nso_getOptPos, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_getOptPos)},
    {SIP_MLNAME_CAST(sipName_getWeights), meth_ChainIkSolverVel_pinv_nso_getWeights, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_getWeights)},
    {SIP_MLNAME_CAST(sipName_setAlpha), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_setAlpha, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_setAlpha)},
    {SIP_MLNAME_CAST(sipName_setOptPos), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_setOptPos, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_setOptPos)},
    {SIP_MLNAME_CAST(sipName_setWeights), (PyCFunction)meth_ChainIkSolverVel_pinv_nso_setWeights, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_setWeights)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_pinv_nso_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_nso_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_nso, "\1ChainIkSolverVel_pinv_nso(chain: Chain, eps: float = 1e-05, maxiter: int = 150, alpha: float = 0.25)\n"
"ChainIkSolverVel_pinv_nso(ChainIkSolverVel_pinv_nso)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_pinv_nso = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_pinv_nso,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverVel_pinv_nso,
        {0, 0, 1},
        8, methods_ChainIkSolverVel_pinv_nso,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_pinv_nso,
    -1,
    -1,
    supers_ChainIkSolverVel_pinv_nso,
    0,
    init_type_ChainIkSolverVel_pinv_nso,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_pinv_nso,
    0,
    0,
    0,
    release_ChainIkSolverVel_pinv_nso,
    cast_ChainIkSolverVel_pinv_nso,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 623 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolverpos_lma.hpp>
using namespace KDL;
#line 1149 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

#line 241 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 1154 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 280 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 1158 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 201 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1164 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverPos_LMA : public  ::ChainIkSolverPos_LMA
{
public:
    sipChainIkSolverPos_LMA(const  ::Chain&,double,int,double);
    sipChainIkSolverPos_LMA(const  ::ChainIkSolverPos_LMA&);
    virtual ~sipChainIkSolverPos_LMA();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Frame&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverPos_LMA(const sipChainIkSolverPos_LMA &);
    sipChainIkSolverPos_LMA &operator = (const sipChainIkSolverPos_LMA &);

    char sipPyMethods[2];
};

sipChainIkSolverPos_LMA::sipChainIkSolverPos_LMA(const  ::Chain& a0,double a1,int a2,double a3):  ::ChainIkSolverPos_LMA(a0,a1,a2,a3), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_LMA::sipChainIkSolverPos_LMA(const  ::ChainIkSolverPos_LMA& a0):  ::ChainIkSolverPos_LMA(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverPos_LMA::~sipChainIkSolverPos_LMA()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverPos_LMA::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverPos_LMA::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverPos_LMA::CartToJnt(const  ::JntArray& a0,const  ::Frame& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverPos_LMA::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_5(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Frame&, ::JntArray&);

    return sipVH_PyKDL_5(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverPos_LMA_CartToJnt, "CartToJnt(self, q_init: JntArray, p_in: Frame, q_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverPos_LMA_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_LMA_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Frame* a1;
         ::JntArray* a2;
         ::ChainIkSolverPos_LMA *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_init,
            sipName_p_in,
            sipName_q_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverPos_LMA, &sipCpp, sipType_JntArray, &a0, sipType_Frame, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_LMA::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_LMA, sipName_CartToJnt, doc_ChainIkSolverPos_LMA_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverPos_LMA_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverPos_LMA_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverPos_LMA_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverPos_LMA *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverPos_LMA, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverPos_LMA::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverPos_LMA, sipName_updateInternalDataStructures, doc_ChainIkSolverPos_LMA_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverPos_LMA(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverPos_LMA(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverPos_LMA *sipCpp = reinterpret_cast< ::ChainIkSolverPos_LMA *>(sipCppV);

    if (targetType == sipType_ChainIkSolverPos)
        return static_cast< ::ChainIkSolverPos *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverPos_LMA(void *, int);}
static void release_ChainIkSolverPos_LMA(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverPos_LMA *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverPos_LMA *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverPos_LMA(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverPos_LMA(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverPos_LMA *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverPos_LMA(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverPos_LMA(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverPos_LMA(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverPos_LMA *sipCpp = 0;

    {
        const  ::Chain* a0;
        double a1 = 1e-05;
        int a2 = 500;
        double a3 = 1e-15;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName__maxiter,
            sipName__eps_joints,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|did", sipType_Chain, &a0, &a1, &a2, &a3))
        {
            sipCpp = new sipChainIkSolverPos_LMA(*a0,a1,a2,a3);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverPos_LMA* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverPos_LMA, &a0))
        {
            sipCpp = new sipChainIkSolverPos_LMA(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverPos_LMA[] = {{8, 255, 1}};


static PyMethodDef methods_ChainIkSolverPos_LMA[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverPos_LMA_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_LMA_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverPos_LMA_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverPos_LMA_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverPos_LMA, "\1ChainIkSolverPos_LMA(chain: Chain, eps: float = 1e-05, _maxiter: int = 500, _eps_joints: float = 1e-15)\n"
"ChainIkSolverPos_LMA(ChainIkSolverPos_LMA)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverPos_LMA = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverPos_LMA,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverPos_LMA,
        {0, 0, 1},
        2, methods_ChainIkSolverPos_LMA,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverPos_LMA,
    -1,
    -1,
    supers_ChainIkSolverPos_LMA,
    0,
    init_type_ChainIkSolverPos_LMA,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverPos_LMA,
    0,
    0,
    0,
    release_ChainIkSolverPos_LMA,
    cast_ChainIkSolverPos_LMA,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 536 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_wdls.hpp>
using namespace KDL;
#line 1459 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

#line 241 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 1464 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 280 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 1468 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 281 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1474 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverVel_wdls : public  ::ChainIkSolverVel_wdls
{
public:
    sipChainIkSolverVel_wdls(const  ::Chain&,double,int);
    sipChainIkSolverVel_wdls(const  ::ChainIkSolverVel_wdls&);
    virtual ~sipChainIkSolverVel_wdls();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_wdls(const sipChainIkSolverVel_wdls &);
    sipChainIkSolverVel_wdls &operator = (const sipChainIkSolverVel_wdls &);

    char sipPyMethods[2];
};

sipChainIkSolverVel_wdls::sipChainIkSolverVel_wdls(const  ::Chain& a0,double a1,int a2):  ::ChainIkSolverVel_wdls(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_wdls::sipChainIkSolverVel_wdls(const  ::ChainIkSolverVel_wdls& a0):  ::ChainIkSolverVel_wdls(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_wdls::~sipChainIkSolverVel_wdls()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverVel_wdls::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverVel_wdls::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_wdls::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverVel_wdls::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel_wdls *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_wdls::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_CartToJnt, doc_ChainIkSolverVel_wdls_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverVel_wdls *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_wdls::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_wdls_updateInternalDataStructures);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_setWeightTS, "setWeightTS(self, List)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_setWeightTS(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_setWeightTS(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
         ::ChainIkSolverVel_wdls *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BT", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, &PyList_Type, &a0))
        {
            int sipIsErr = 0;

#line 547 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    //void setWeightTS(const Eigen::MatrixXd& Mx);
    //Mx has to be a 6x6 Matrix

    Py_ssize_t numRows,numCols;
    double c_item;
    PyObject *list=a0;
    numRows=PyList_Size(list);
    PyObject *temp1;
    temp1=PyList_GetItem(list,0);
    numCols=PyList_Size(temp1);
    if (numRows!=numCols) {
       sipIsErr=1; //todo: raise exception
    }
    if (numRows!=6) {
       sipIsErr=1; //todo: raise exception
    }
    Eigen::MatrixXd Mx;
    Mx=Eigen::MatrixXd::Identity(numRows,numCols);
    
    for (Py_ssize_t r=0;r<numRows;r++) {
        PyObject *row;
        row=PyList_GetItem(list,r);
        if (numCols!=PyList_Size(row)) {
           sipIsErr=1; //todo: raise exception
        }
        for (Py_ssize_t c=0;c<numCols;c++) {
            PyObject *item;
            item=PyList_GetItem(row,c);
            c_item=PyFloat_AsDouble(item);
            Mx(r,c)= c_item;
        }
    }
    sipCpp->setWeightTS(Mx);
#line 1667 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_setWeightTS, doc_ChainIkSolverVel_wdls_setWeightTS);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_setWeightJS, "setWeightJS(self, List)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_setWeightJS(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_setWeightJS(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;

    {
        PyObject * a0;
         ::ChainIkSolverVel_wdls *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "BT", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, &PyList_Type, &a0))
        {
            int sipIsErr = 0;

#line 584 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
    //void setWeightJS(const Eigen::MatrixXd& Mx);
    //Mx has to be a simetric positive definite Matrix
    //unsigned int nOfJoints=sipCpp->chain.getNrOfJoints(); //To check that we are receiving valid data dimensions. This doesn't work, chain is a private member. todo: How can we check for this?
    Py_ssize_t numRows,numCols;
    double c_item;
    PyObject *list=a0;
    numRows=PyList_Size(list);
    PyObject *temp1;
    temp1=PyList_GetItem(list,0);
    numCols=PyList_Size(temp1);
    if (numRows!=numCols) {
       sipIsErr=1; //todo: raise exception
    }
    Eigen::MatrixXd Mq;
    Mq=Eigen::MatrixXd::Identity(numRows,numCols);
    for (Py_ssize_t r=0;r<numRows;r++) {
        PyObject *row;
        row=PyList_GetItem(list,r);
        if (numCols!=PyList_Size(row)) {
           sipIsErr=1; //todo: raise exception
        }
        for (Py_ssize_t c=0;c<numCols;c++) {
            PyObject *item;
            item=PyList_GetItem(row,c);
            c_item=PyFloat_AsDouble(item);
            Mq(r,c)= c_item;
        }
    }
    sipCpp->setWeightJS(Mq);
#line 1730 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

            if (sipIsErr)
                return 0;

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_setWeightJS, doc_ChainIkSolverVel_wdls_setWeightJS);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_wdls_setLambda, "setLambda(self, lambda_: float)");

extern "C" {static PyObject *meth_ChainIkSolverVel_wdls_setLambda(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_wdls_setLambda(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;

    {
        double a0;
         ::ChainIkSolverVel_wdls *sipCpp;

        static const char *sipKwdList[] = {
            sipName_lambda,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "Bd", &sipSelf, sipType_ChainIkSolverVel_wdls, &sipCpp, &a0))
        {
            sipCpp->setLambda(a0);

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_wdls, sipName_setLambda, doc_ChainIkSolverVel_wdls_setLambda);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_wdls(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_wdls(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel_wdls *sipCpp = reinterpret_cast< ::ChainIkSolverVel_wdls *>(sipCppV);

    if (targetType == sipType_ChainIkSolverVel)
        return static_cast< ::ChainIkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_wdls(void *, int);}
static void release_ChainIkSolverVel_wdls(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_wdls *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel_wdls *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_wdls(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_wdls(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_wdls *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel_wdls(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_wdls(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_wdls(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_wdls *sipCpp = 0;

    {
        const  ::Chain* a0;
        double a1 = 1e-05;
        int a2 = 150;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName_maxiter,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|di", sipType_Chain, &a0, &a1, &a2))
        {
            sipCpp = new sipChainIkSolverVel_wdls(*a0,a1,a2);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel_wdls* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_wdls, &a0))
        {
            sipCpp = new sipChainIkSolverVel_wdls(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_wdls[] = {{12, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_wdls[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_wdls_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_setLambda), (PyCFunction)meth_ChainIkSolverVel_wdls_setLambda, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_setLambda)},
    {SIP_MLNAME_CAST(sipName_setWeightJS), meth_ChainIkSolverVel_wdls_setWeightJS, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_setWeightJS)},
    {SIP_MLNAME_CAST(sipName_setWeightTS), meth_ChainIkSolverVel_wdls_setWeightTS, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_setWeightTS)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_wdls_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_wdls_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_wdls, "\1ChainIkSolverVel_wdls(chain: Chain, eps: float = 1e-05, maxiter: int = 150)\n"
"ChainIkSolverVel_wdls(ChainIkSolverVel_wdls)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_wdls = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_wdls,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverVel_wdls,
        {0, 0, 1},
        5, methods_ChainIkSolverVel_wdls,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_wdls,
    -1,
    -1,
    supers_ChainIkSolverVel_wdls,
    0,
    init_type_ChainIkSolverVel_wdls,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_wdls,
    0,
    0,
    0,
    release_ChainIkSolverVel_wdls,
    cast_ChainIkSolverVel_wdls,
    0,
    0,
    0,
    0,
    0,
    0
};

#line 523 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chainiksolvervel_pinv.hpp>
using namespace KDL;
#line 1932 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"

#line 241 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/chain.hpp>
using namespace KDL;
#line 1937 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 280 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/kinfam.sip"
#include <kdl/jntarray.hpp>
using namespace KDL;
#line 1941 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"
#line 281 "/home/ntnghia1999/dynamics_final/src/orocos_kinematics_dynamics/python_orocos_kdl/PyKDL/frames.sip"
#include <kdl/frames.hpp>
#include <kdl/frames_io.hpp>
#include <sstream>
using namespace KDL;
#line 1947 "/home/ntnghia1999/dynamics_final/build/python_orocos_kdl/PyKDL/sipPyKDLpart2.cpp"


class sipChainIkSolverVel_pinv : public  ::ChainIkSolverVel_pinv
{
public:
    sipChainIkSolverVel_pinv(const  ::Chain&,double,int);
    sipChainIkSolverVel_pinv(const  ::ChainIkSolverVel_pinv&);
    virtual ~sipChainIkSolverVel_pinv();

    /*
     * There is a protected method for every virtual method visible from
     * this class.
     */
protected:
    void updateInternalDataStructures();
    int CartToJnt(const  ::JntArray&,const  ::Twist&, ::JntArray&);

public:
    sipSimpleWrapper *sipPySelf;

private:
    sipChainIkSolverVel_pinv(const sipChainIkSolverVel_pinv &);
    sipChainIkSolverVel_pinv &operator = (const sipChainIkSolverVel_pinv &);

    char sipPyMethods[2];
};

sipChainIkSolverVel_pinv::sipChainIkSolverVel_pinv(const  ::Chain& a0,double a1,int a2):  ::ChainIkSolverVel_pinv(a0,a1,a2), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv::sipChainIkSolverVel_pinv(const  ::ChainIkSolverVel_pinv& a0):  ::ChainIkSolverVel_pinv(a0), sipPySelf(0)
{
    memset(sipPyMethods, 0, sizeof (sipPyMethods));
}

sipChainIkSolverVel_pinv::~sipChainIkSolverVel_pinv()
{
    sipInstanceDestroyed(sipPySelf);
}

void sipChainIkSolverVel_pinv::updateInternalDataStructures()
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[0],sipPySelf,NULL,sipName_updateInternalDataStructures);

    if (!sipMeth)
    {
         ::ChainIkSolverVel_pinv::updateInternalDataStructures();
        return;
    }

    extern void sipVH_PyKDL_2(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *);

    sipVH_PyKDL_2(sipGILState, 0, sipPySelf, sipMeth);
}

int sipChainIkSolverVel_pinv::CartToJnt(const  ::JntArray& a0,const  ::Twist& a1, ::JntArray& a2)
{
    sip_gilstate_t sipGILState;
    PyObject *sipMeth;

    sipMeth = sipIsPyMethod(&sipGILState,&sipPyMethods[1],sipPySelf,NULL,sipName_CartToJnt);

    if (!sipMeth)
        return  ::ChainIkSolverVel_pinv::CartToJnt(a0,a1,a2);

    extern int sipVH_PyKDL_6(sip_gilstate_t, sipVirtErrorHandlerFunc, sipSimpleWrapper *, PyObject *, const  ::JntArray&,const  ::Twist&, ::JntArray&);

    return sipVH_PyKDL_6(sipGILState, 0, sipPySelf, sipMeth, a0, a1, a2);
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_CartToJnt, "CartToJnt(self, q_in: JntArray, v_in: Twist, qdot_out: JntArray) -> int");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_CartToJnt(PyObject *, PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_CartToJnt(PyObject *sipSelf, PyObject *sipArgs, PyObject *sipKwds)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
        const  ::JntArray* a0;
        const  ::Twist* a1;
         ::JntArray* a2;
         ::ChainIkSolverVel_pinv *sipCpp;

        static const char *sipKwdList[] = {
            sipName_q_in,
            sipName_v_in,
            sipName_qdot_out,
        };

        if (sipParseKwdArgs(&sipParseErr, sipArgs, sipKwds, sipKwdList, NULL, "BJ9J9J9", &sipSelf, sipType_ChainIkSolverVel_pinv, &sipCpp, sipType_JntArray, &a0, sipType_Twist, &a1, sipType_JntArray, &a2))
        {
            int sipRes;

            sipRes = (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv::CartToJnt(*a0,*a1,*a2) : sipCpp->CartToJnt(*a0,*a1,*a2));

            return SIPLong_FromLong(sipRes);
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv, sipName_CartToJnt, doc_ChainIkSolverVel_pinv_CartToJnt);

    return NULL;
}


PyDoc_STRVAR(doc_ChainIkSolverVel_pinv_updateInternalDataStructures, "updateInternalDataStructures(self)");

extern "C" {static PyObject *meth_ChainIkSolverVel_pinv_updateInternalDataStructures(PyObject *, PyObject *);}
static PyObject *meth_ChainIkSolverVel_pinv_updateInternalDataStructures(PyObject *sipSelf, PyObject *sipArgs)
{
    PyObject *sipParseErr = NULL;
    bool sipSelfWasArg = (!sipSelf || sipIsDerivedClass((sipSimpleWrapper *)sipSelf));

    {
         ::ChainIkSolverVel_pinv *sipCpp;

        if (sipParseArgs(&sipParseErr, sipArgs, "B", &sipSelf, sipType_ChainIkSolverVel_pinv, &sipCpp))
        {
            (sipSelfWasArg ? sipCpp-> ::ChainIkSolverVel_pinv::updateInternalDataStructures() : sipCpp->updateInternalDataStructures());

            Py_INCREF(Py_None);
            return Py_None;
        }
    }

    /* Raise an exception if the arguments couldn't be parsed. */
    sipNoMethod(sipParseErr, sipName_ChainIkSolverVel_pinv, sipName_updateInternalDataStructures, doc_ChainIkSolverVel_pinv_updateInternalDataStructures);

    return NULL;
}


/* Cast a pointer to a type somewhere in its inheritance hierarchy. */
extern "C" {static void *cast_ChainIkSolverVel_pinv(void *, const sipTypeDef *);}
static void *cast_ChainIkSolverVel_pinv(void *sipCppV, const sipTypeDef *targetType)
{
     ::ChainIkSolverVel_pinv *sipCpp = reinterpret_cast< ::ChainIkSolverVel_pinv *>(sipCppV);

    if (targetType == sipType_ChainIkSolverVel)
        return static_cast< ::ChainIkSolverVel *>(sipCpp);

    if (targetType == sipType_SolverI)
        return static_cast< ::SolverI *>(sipCpp);

    return sipCppV;
}


/* Call the instance's destructor. */
extern "C" {static void release_ChainIkSolverVel_pinv(void *, int);}
static void release_ChainIkSolverVel_pinv(void *sipCppV, int sipState)
{
    if (sipState & SIP_DERIVED_CLASS)
        delete reinterpret_cast<sipChainIkSolverVel_pinv *>(sipCppV);
    else
        delete reinterpret_cast< ::ChainIkSolverVel_pinv *>(sipCppV);
}


extern "C" {static void dealloc_ChainIkSolverVel_pinv(sipSimpleWrapper *);}
static void dealloc_ChainIkSolverVel_pinv(sipSimpleWrapper *sipSelf)
{
    if (sipIsDerivedClass(sipSelf))
        reinterpret_cast<sipChainIkSolverVel_pinv *>(sipGetAddress(sipSelf))->sipPySelf = NULL;

    if (sipIsOwnedByPython(sipSelf))
    {
        release_ChainIkSolverVel_pinv(sipGetAddress(sipSelf), sipIsDerivedClass(sipSelf));
    }
}


extern "C" {static void *init_type_ChainIkSolverVel_pinv(sipSimpleWrapper *, PyObject *, PyObject *, PyObject **, PyObject **, PyObject **);}
static void *init_type_ChainIkSolverVel_pinv(sipSimpleWrapper *sipSelf, PyObject *sipArgs, PyObject *sipKwds, PyObject **sipUnused, PyObject **, PyObject **sipParseErr)
{
    sipChainIkSolverVel_pinv *sipCpp = 0;

    {
        const  ::Chain* a0;
        double a1 = 1e-05;
        int a2 = 150;

        static const char *sipKwdList[] = {
            sipName_chain,
            sipName_eps,
            sipName_maxiter,
        };

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, sipKwdList, sipUnused, "J9|di", sipType_Chain, &a0, &a1, &a2))
        {
            sipCpp = new sipChainIkSolverVel_pinv(*a0,a1,a2);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    {
        const  ::ChainIkSolverVel_pinv* a0;

        if (sipParseKwdArgs(sipParseErr, sipArgs, sipKwds, NULL, sipUnused, "J9", sipType_ChainIkSolverVel_pinv, &a0))
        {
            sipCpp = new sipChainIkSolverVel_pinv(*a0);

            sipCpp->sipPySelf = sipSelf;

            return sipCpp;
        }
    }

    return NULL;
}


/* Define this type's super-types. */
static sipEncodedTypeDef supers_ChainIkSolverVel_pinv[] = {{12, 255, 1}};


static PyMethodDef methods_ChainIkSolverVel_pinv[] = {
    {SIP_MLNAME_CAST(sipName_CartToJnt), (PyCFunction)meth_ChainIkSolverVel_pinv_CartToJnt, METH_VARARGS|METH_KEYWORDS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_CartToJnt)},
    {SIP_MLNAME_CAST(sipName_updateInternalDataStructures), meth_ChainIkSolverVel_pinv_updateInternalDataStructures, METH_VARARGS, SIP_MLDOC_CAST(doc_ChainIkSolverVel_pinv_updateInternalDataStructures)}
};

PyDoc_STRVAR(doc_ChainIkSolverVel_pinv, "\1ChainIkSolverVel_pinv(chain: Chain, eps: float = 1e-05, maxiter: int = 150)\n"
"ChainIkSolverVel_pinv(ChainIkSolverVel_pinv)");


sipClassTypeDef sipTypeDef_PyKDL_ChainIkSolverVel_pinv = {
    {
        -1,
        0,
        0,
        SIP_TYPE_CLASS,
        sipNameNr_ChainIkSolverVel_pinv,
        {0},
        0
    },
    {
        sipNameNr_ChainIkSolverVel_pinv,
        {0, 0, 1},
        2, methods_ChainIkSolverVel_pinv,
        0, 0,
        0, 0,
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    },
    doc_ChainIkSolverVel_pinv,
    -1,
    -1,
    supers_ChainIkSolverVel_pinv,
    0,
    init_type_ChainIkSolverVel_pinv,
    0,
    0,
#if PY_MAJOR_VERSION >= 3
    0,
    0,
#else
    0,
    0,
    0,
    0,
#endif
    dealloc_ChainIkSolverVel_pinv,
    0,
    0,
    0,
    release_ChainIkSolverVel_pinv,
    cast_ChainIkSolverVel_pinv,
    0,
    0,
    0,
    0,
    0,
    0
};
